<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>开车上纽北</title>
  <subtitle>一个在灯红酒绿的大城市五环外飙车的老司机</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.ruanjiawei.com/"/>
  <updated>2017-02-12T05:33:20.000Z</updated>
  <id>http://www.ruanjiawei.com/</id>
  
  <author>
    <name>Calvin1992</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React-Native安卓中实现图片的placeholder</title>
    <link href="http://www.ruanjiawei.com/2017/02/11/react-native-image-placeholder/"/>
    <id>http://www.ruanjiawei.com/2017/02/11/react-native-image-placeholder/</id>
    <published>2017-02-11T12:50:45.000Z</published>
    <updated>2017-02-12T05:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>用React-Native开发进入一定境界之后，越发觉得用RN来开发基于安卓平台的应用就是个大坑，因为好像官方根本就不怎么关心安卓平台的开发体验。</p>
<p>说说最近比较恶心RN官方的原因。最近为了提高用户体验，打算给图片加一个placeholder，当用户加载图片失败后，给一个替代的默认图片用以展示给用户。但是当你浏览官方的文档后，你会发现，这个功能在iOS下给 <code>Image</code> 组件提供了一个叫 <code>defaultSource</code> 的属性，用以实现我们想要的功能。然而，这个属性是用标记了 <code>iOS</code> 的，也就是说，这个属性只支持iOS平台。</p>
<p>可能你会想，我自己用js实现一个咯。哈哈，对不起，你根本没有相关的钩子去获取图片加载失败与否。当你浏览文档，你会发现 <code>onError</code> 钩子也只有iOS平台专享，唯一的能用的 <code>onLoadEnd</code> 却没有意义，因为通过这个钩子拿到的事件对象是空的，无论加载成功与否。</p>
<p>到这里，我们是不是有点悲观了。等等，当你仔细浏览文档，你会发现，<code>Image</code> 是可以嵌套的！这意味着，你可以把placeholde的Image或者Text嵌入在外层的Image中，通过设置zIndex为小于外层Image的zIndex来实现这个效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">  <span class="comment">// 内外层的style除了zIndex外，保持一致</span></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;Image </div><div class="line">      style=&#123;imageStyle&#125; </div><div class="line">      dataSource=&#123;&#123;uri: 'imageSource'&#125;&#125;&gt;</div><div class="line">      &lt;Image </div><div class="line">        style=&#123;[imageStyle, &#123;zIndex: -1&#125;]&#125; </div><div class="line">        dataSource=&#123;&#123;uri: 'imageSource'&#125;&#125; /&gt;</div><div class="line">    &lt;/Image&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然有些Hack，但还是挺优雅的，是吧。</p>
<p>当然，如果你Java不错，建议通过编写本地模块，让其通过JS连接来实现，但是这个可能就比较为难纯前端的小伙伴了。其实，如果让我通过编写本地模块去实现，我倒觉得更Hack了。如果你是把项目运行在iOS平台，则完全可以使用官方的 <code>defaultSource</code> 或者通过官方提供的一些钩子函数去实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用React-Native开发进入一定境界之后，越发觉得用RN来开发基于安卓平台的应用就是个大坑，因为好像官方根本就不怎么关心安卓平台的开发体验。&lt;/p&gt;
&lt;p&gt;说说最近比较恶心RN官方的原因。最近为了提高用户体验，打算给图片加一个placeholder，当用户加载图片失败
    
    </summary>
    
      <category term="JS-APP" scheme="http://www.ruanjiawei.com/categories/JS-APP/"/>
    
    
      <category term="react-native" scheme="http://www.ruanjiawei.com/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>React-Native安卓开发中的坑</title>
    <link href="http://www.ruanjiawei.com/2017/02/08/react-native-issues/"/>
    <id>http://www.ruanjiawei.com/2017/02/08/react-native-issues/</id>
    <published>2017-02-08T12:50:45.000Z</published>
    <updated>2017-02-09T14:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何一项通往成熟道路上的技术都遍布着各种各样的坑，而这些坑，需要广大的过客去踩，去填，才有可能最终走向成熟，否则就是胎死腹中。 </p>
<p>React-Native的安卓版本已经发布一年多了，但是相比起iOS版本，真是嫩多了，换句话就是，太特么多坑了～</p>
<p>下面总结几个这段时间遇到的特别明显的坑，以便警醒后人：</p>
<h3 id="ListView的onEndReached不能触发"><a href="#ListView的onEndReached不能触发" class="headerlink" title="ListView的onEndReached不能触发"></a>ListView的onEndReached不能触发</h3><p>ListView在安卓下，onEndReached句柄并不好用，尤其是在ListView嵌套在ScrollView的情况下。GitHub上也有很多的issue是关于这个问题的，所以如果你想使用onEndReached来实现 <code>加载更多</code> 的功能的话，建议自己实现onScroll方法。我的项目实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">render () &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;ListView</div><div class="line">      onScroll=&#123;e =&gt; DeviceEventEmitter.emit('isScrolling', e)&#125; // 只需要关注这句</div><div class="line">      dataSource=&#123;this.state.dataSource.cloneWithRows(this.props.newsList[this.props.channelKey])&#125;</div><div class="line">      ref=&#123;listView =&gt; &#123; this._listView = listView &#125;&#125;</div><div class="line">      enableEmptySections=&#123;true&#125;</div><div class="line">      renderHeader=&#123;this.renderHeader.bind(this)&#125;</div><div class="line">      renderRow=&#123;this.renderRow.bind(this)&#125;</div><div class="line">      renderFooter=&#123;this.renderLoadMore.bind(this)&#125;</div><div class="line">      showsVerticalScrollIndicator=&#123;false&#125;</div><div class="line">    /&gt;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 添加绑定事件</div><div class="line">componentDidMount() &#123;</div><div class="line">  DeviceEventEmitter.addListener('isScrolling', (e) =&gt; this.handleScroll(e))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 滚动控制</div><div class="line">handleScroll(e) &#123;</div><div class="line">  const contentHeight = e.nativeEvent.contentSize.height</div><div class="line">  const offsetY = e.nativeEvent.contentOffset.y</div><div class="line"></div><div class="line">  // 这个threshold的结果最大值是系统状态栏的高度 25-38之间</div><div class="line">  const threshold = WINDOW_HEIGHT + offsetY - contentHeight</div><div class="line"></div><div class="line">  if (threshold &gt;= 0 &amp;&amp; !this.props.fetching) &#123;</div><div class="line">    // handle loadMore</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="react-native-scrollable-tab-view组件的initialPage不等于0时不喧染"><a href="#react-native-scrollable-tab-view组件的initialPage不等于0时不喧染" class="headerlink" title="react-native-scrollable-tab-view组件的initialPage不等于0时不喧染"></a>react-native-scrollable-tab-view组件的initialPage不等于0时不喧染</h3><p>这是个非常流行的第三方组件，当你使用 <code>0.7.0</code> 以上版本遇到这个坑时，别激动，这是个官方的bug，不要浪费太多时间在这上面了，只需要把版本降低到 <code>0.6.x</code>  就可以了。</p>
<h3 id="ListView需要在滚动的时候才渲染结果"><a href="#ListView需要在滚动的时候才渲染结果" class="headerlink" title="ListView需要在滚动的时候才渲染结果"></a>ListView需要在滚动的时候才渲染结果</h3><p>这个bug很普遍，当你从一个场景切换回一个ListView场景，或者当你从比较大数据量的dataSource的ListView中，滚动到ListView的下方，把整个dataSource变成小数据量时（典型的是Tab切换时，切换数据源的显示），这个bug就会出现了。官方目前还没有好的解决方案，但是有的人可以通过把ListView的 <code>removeClippedSubViews</code> 设置为 <code>false</code> 解决。</p>
<p>这不是一个很好的解决方案，毕竟这个会引起一定的性能问题，但是它能缓解你的燃眉之急。</p>
<h3 id="componentDidMount中不能操作ScrollView实例"><a href="#componentDidMount中不能操作ScrollView实例" class="headerlink" title="componentDidMount中不能操作ScrollView实例"></a>componentDidMount中不能操作ScrollView实例</h3><p>当你像我这样，打算在componentDidMount中对ScrollView进行操作时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">  <span class="keyword">this</span>._scrollView.scrollTo(&#123;<span class="attr">y</span>: <span class="number">0</span>, <span class="attr">x</span>: <span class="keyword">this</span>.currentOffsetX, <span class="attr">animated</span>: <span class="literal">true</span>&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">render() &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;Animated.View style=&#123;&#123;height: 140, marginTop: this.state.shrink&#125;&#125;&gt;</div><div class="line">      &lt;Image</div><div class="line">        source=&#123;&#123;uri: this.props.channel.images[0].url&#125;&#125;</div><div class="line">        style=&#123;styles.backgroundImage&#125;</div><div class="line">      /&gt;</div><div class="line">      &lt;ScrollView</div><div class="line">        ref=&#123;scrollView =&gt; &#123; this._scrollView = scrollView &#125;&#125; // 注意这里就行</div><div class="line">        horizontal=&#123;true&#125;</div><div class="line">        scrollEnabled=&#123;false&#125;</div><div class="line">        showsHorizontalScrollIndicator=&#123;false&#125;</div><div class="line">        scrollsToTop=&#123;false&#125;</div><div class="line">        style=&#123;styles.mt70&#125;&gt;</div><div class="line">        &lt;View style=&#123;styles.channelsTabView&#125;&gt;</div><div class="line">          &#123;channelItems&#125;</div><div class="line">        &lt;/View&gt;</div><div class="line">      &lt;/ScrollView&gt;</div><div class="line">    &lt;/Animated.View&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我可以很负责任地告诉你，这样行不通。因为在安卓中，因为有动画，你在componentDidMount中是拿不到 <code>this._scrollView</code> 的，也就是其为 <code>undefined</code> 或者是你在构造函数中设置的初始值。解决这个可以使用 <code>InteractionManager.runAfterInteractions</code> 配合setTimeout来解决，但这个不是很好的解决办法，后续如果我找到更好的解决方案，会更新给大家。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">InteractionManager.runAfterInteractions(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>._scrollView &amp;&amp; <span class="keyword">this</span>._scrollView.scrollTo(&#123;<span class="attr">y</span>: <span class="number">0</span>, <span class="attr">x</span>: <span class="keyword">this</span>.currentOffsetX, <span class="attr">animated</span>: <span class="literal">true</span>&#125;)</div><div class="line">  &#125;, <span class="number">60</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="WebView嵌套在View中时，无法显示"><a href="#WebView嵌套在View中时，无法显示" class="headerlink" title="WebView嵌套在View中时，无法显示"></a>WebView嵌套在View中时，无法显示</h3><p>这个问题出现在，当你的WebView不是出现在一个场景(scene)中的最顶层，而是嵌套在View或者其他类似的组件中的时候，你会发现这个WebView完全没有显示出来。这是因为你必须显式地给WebView设置一个高度，否则它不知道怎么layout(布局)。</p>
<p>解决这个问题不难，给这个WebView的style设置 <code>{flex: 1}</code> 即可。</p>
<h3 id="大量图片的ListView会在加载一部份row后，图片不再显示"><a href="#大量图片的ListView会在加载一部份row后，图片不再显示" class="headerlink" title="大量图片的ListView会在加载一部份row后，图片不再显示"></a>大量图片的ListView会在加载一部份row后，图片不再显示</h3><p>对于这个问题，我先贴一个地址：<a href="https://github.com/facebook/react-native/issues/8677" target="_blank" rel="external">传送门</a></p>
<p>稍晚点我会对这个问题进行更新～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任何一项通往成熟道路上的技术都遍布着各种各样的坑，而这些坑，需要广大的过客去踩，去填，才有可能最终走向成熟，否则就是胎死腹中。 &lt;/p&gt;
&lt;p&gt;React-Native的安卓版本已经发布一年多了，但是相比起iOS版本，真是嫩多了，换句话就是，太特么多坑了～&lt;/p&gt;
&lt;p&gt;下
    
    </summary>
    
      <category term="JS-APP" scheme="http://www.ruanjiawei.com/categories/JS-APP/"/>
    
    
      <category term="react-native" scheme="http://www.ruanjiawei.com/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>送别2016</title>
    <link href="http://www.ruanjiawei.com/2017/01/15/2016-summary/"/>
    <id>http://www.ruanjiawei.com/2017/01/15/2016-summary/</id>
    <published>2017-01-15T12:50:45.000Z</published>
    <updated>2017-02-09T06:57:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>“老哥，什么时候回家过年？”</p>
<p>催泪弹啊。</p>
<p>记得去年回家过年的时候，请了两天假，总共在家呆了八天，但是现在我使劲回想那八天我到底做了些什么的时候，却怎么也还原不了一件让我印象深刻的事情。并不是因为觉得遥远，相反，我觉得去年过年的那段光景就如昨日一样。也许，是长大了，健忘，抑或是因为每天忙忙碌碌，为生活奔波，生活过得被动而毫无滋味。细思，觉着后者可能性更大。</p>
<p>没错，2016年我都在奔波。这一年，我有很多想法，也做了很多事情，虽然总体来说还是比较失败，但是学到了很多。不可否认，这种过活方式其实相当乏味可陈，但是不晓得为啥，好像这一年我就喜欢这样让自己奔波，而不像在学校的时候经常把自己关在寝室或者逗留在台球室，日子过得迷茫不堪。</p>
<p>是啊，有时候日子虽然过得不是那么有滋味，但是总比乏味好。这一年，总体来说，波澜不惊。期间经历的几件印象深刻的事情无非就是年中的时候换工作的折腾和一次出车祸带来的那段心力交瘁的日子。</p>
<p>换工作的艰辛就不赘述了，前面有详细的一篇文章作描述。车祸也不打算详尽述说，总之，伤身也伤钱包。</p>
<p>下半年，换了一个工作，从广州来到了深圳，从一个团队换到另一个团队。在新的环境磨练了三个多月，成长了很多，无论是关于技能还是对人生的感悟。</p>
<p>在深圳的三个多月里，我的技术栈丰富了很多，装下了Vue全家桶、Express服务框架、MongoDB等。那段时间不轻松，因为要接受不少新鲜的东西，还要用这些新鲜的东西去做成品的项目。很幸运，12月底上线了轻氧的WEB版本，也算是没有辜负自己。</p>
<p>其实在深圳这段时间，最触动我的，并不是工作相关的，而是关于生存这个沉重的话题。换工作，避免不了租房子。我对住房的要求并不高，因为我是经历过在北京艰难找房的经历的人。深圳比起北京，真的强了很多，起码房子不会是地下室（也许有，但我没注意到）。城中村的房子虽然简陋，但是光线还是足够的。在我来之前，我姐给我找了很多房子，价格从几百到几千不等。好在公司在宝安区这边，房价相对南山等地要便宜，于是在西乡租个1000多的单间倒也安逸了。</p>
<p>真正的感概并不是来自于我自身的经历，而是来自于自己眼睛看到和耳朵听到的别人的经历。深圳的房价已经到了让人90度仰望的地步，朋友A毕业前，在我们眼里是个小土豪，家里在一个2.5线城市持有一套别墅和两套商品房。毕业一年后，把家里的别墅和一套商品房卖了，在深圳付了5成首付，贷款300万在前海买了一套期房。我问他一个月要还多少贷款，答案是2万出头。有时候我都开始怀疑奋斗是否真的有意义，如果有，为何我们连生存的问题都没能解决呢。</p>
<p>一个多月前，公司楼下新开了一家面包店。自开店以来，我从来没有见过店里面有任何一个客人。元旦回来的时候，我进店里逛了两分钟有余，店里老板娘像发现了新大陆一样蹦蹦跳跳地从里屋出来，笑称我是她店里这三天里的第一个客人，坚持要给我会员卡，免费办的，全场打6折。我说店里的面包不便宜呀～6折卡对我也没啥意义呀～老板娘听到这有点着急，说这些面包都是手工做的，店里租金一个月一万五，做这个纯粹是因为兴趣blabla～</p>
<p>最后我买了两块面包，但我没要那个会员卡。我知道，她的经营问题，靠她的兴趣是支撑不下去的，在高昂的亏损面前，我甚至希望她尽快逃离这里，以便尽快脱离无止尽的亏损。 </p>
<p>前些天，我丢了一点钱在老家的市里，支撑老家房地产，替国家接了盘～也算是对大城市高昂的房价做了一次蚍蜉撼大树的抵抗。抵抗还是要有的，起码我心安。</p>
<p>完。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;恍恍惚惚又一年，又到了怀旧的季节。这一年，最大的变化，应该就是公司对面的楼盘的价格从年初的5万一平到年底的12万一平吧～&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.ruanjiawei.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="死宅" scheme="http://www.ruanjiawei.com/tags/%E6%AD%BB%E5%AE%85/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个基于Vue2.0插件</title>
    <link href="http://www.ruanjiawei.com/2016/12/18/how-to-implement-a-vue2-plugin/"/>
    <id>http://www.ruanjiawei.com/2016/12/18/how-to-implement-a-vue2-plugin/</id>
    <published>2016-12-18T11:08:15.000Z</published>
    <updated>2017-02-12T09:26:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做<a href="https://app.aotu.io" target="_blank" rel="external">「轻氧」</a> 的Web版本。项目的技术栈主要使用了Express + MongoDB(leancloud)作为后端，Vue2.0 + Vuex + SSR作为前端选型。</p>
<p>项目目前已经到了开发的后期预测试阶段，在交给老大确认需要修改的细节的时候，老大希望仅有的几个alert采用自定义组件的实现方式。</p>
<p>实现这个需求其实有很多种方法：</p>
<p>一种是在 <code>utilities</code> 通用helper函数中定义一个操作DOM的函数，然后在需要alert的时候把执行这个函数，把DOM插入到根节点中。这种方法可行，但是不够优雅，另外，如果众多模块中使用到这个工具函数，你需要在每个需要用到的模块中手动地 <code>import</code> 一遍。</p>
<p>另一种是，将其实现为一个组件，通过在Vuex的state中定义一个 <code>flag</code> ，控制其为 <code>true</code> 或者 <code>false</code> 来控制其显示或者隐藏。这种实现方式最大的不好之处在于，这个组件必须在根容器中显式地写上，并且，这个ui的控制不应该污染Vuex的数据，而Vuex中的数据应该是项目共享的数据。所以，这种实现方式，最不值得推荐。 </p>
<p>最后一种就是使用Vue插件的实现方式。插件是为Vue添加全局功能的实现方式，按照官方的文档，插件的实现方式主要有以下几种：</p>
<ol>
<li>添加全局方法或者属性，如: vue-element</li>
<li>添加全局资源：指令/过滤器/过渡等，如 vue-touch</li>
<li>通过全局 mixin方法添加一些组件选项，如: vuex</li>
<li>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现</li>
<li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router</li>
</ol>
<p>我们可以使用第四种方法去实现 <code>Toast</code> 这个功能。Vue的插件有一个公开方法 <code>install</code> ，这个方法的第一个参数是 Vue 构造器 , 第二个参数是一个可选的选项对象: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</div><div class="line">  <span class="comment">// 添加实例方法</span></div><div class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="comment">// 逻辑...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这种方法，我们可以简单地把 <code>Toast</code> 功能插件按如下实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// toast.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">install</span>: <span class="function"><span class="keyword">function</span>(<span class="params">Vue, options</span>) </span>&#123;</div><div class="line">    Vue.prototype.$toast = <span class="function"><span class="keyword">function</span>(<span class="params">text = <span class="string">"默认的提示信息"</span>, options = &#123;type: <span class="string">'error'</span>&#125;</span>) </span>&#123;</div><div class="line">      <span class="comment">// console.log(this.$root.$el.className)</span></div><div class="line">      <span class="keyword">let</span> bgColor  = <span class="string">'#bd362f'</span></div><div class="line">      <span class="keyword">let</span> iconType = <span class="string">'fa-exclamation-circle'</span></div><div class="line"></div><div class="line">      <span class="keyword">if</span>(options.type === <span class="string">'success'</span>) &#123;</div><div class="line">        iconType = <span class="string">'fa-check'</span></div><div class="line">        bgColor  = <span class="string">'#51a351'</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> styleForOuter = <span class="string">'position: fixed;display: flex;top: 0;left: 0;'</span> + </div><div class="line">        <span class="string">'width: 100%;height: 100%;justify-content: center;align-items: center;z-index: 9999'</span></div><div class="line">      <span class="keyword">const</span> styleForInner = <span class="string">`background: <span class="subst">$&#123;bgColor&#125;</span>; max-width: 250px; display: flex; padding: 20px; position: relative; overflow: hidden; border-radius: 5px; opacity: 1; transition: opacity .5s linear`</span></div><div class="line"></div><div class="line">      <span class="keyword">const</span> htmlForInner = <span class="string">`</span></div><div class="line">        &lt;div style="width: 30px"&gt;&lt;i class="fa <span class="subst">$&#123;iconType&#125;</span>" style="color: #ffffff; font-size: 20px"&gt;&lt;/i&gt;&lt;/div&gt;</div><div class="line">	      &lt;div style="flex: 1; color: #ffffff"&gt;<span class="subst">$&#123;text&#125;</span>&lt;/div&gt;</div><div class="line">			`</div><div class="line"></div><div class="line">      <span class="keyword">let</span> outerDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</div><div class="line">      outerDiv.style = styleForOuter</div><div class="line">      <span class="keyword">let</span> innerDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</div><div class="line">      innerDiv.style = styleForInner</div><div class="line">      innerDiv.innerHTML = htmlForInner</div><div class="line"></div><div class="line">      outerDiv.appendChild(innerDiv)</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.$root.$el.appendChild(outerDiv)</div><div class="line">	</div><div class="line">      <span class="comment">// toast停留时间 500ms为opacity动画时间</span></div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;innerDiv.style.opacity = <span class="number">0</span>&#125;, <span class="number">1000</span>)</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">this</span>.$root.$el.removeChild(outerDiv)&#125;, <span class="number">1500</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在全局中，注册这个插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// app.js</div><div class="line">Vue.use(Toast)</div></pre></td></tr></table></figure>
<p>在任何想要使用 <code>toast</code> 的组件中，只需要简单地按如下使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.$toast(&apos;想要显示的消息&apos;, options)</div></pre></td></tr></table></figure></p>
<p>整个Vue插件的实现过程，就是如上几步，非常简单，而且优雅。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做&lt;a href=&quot;https://app.aotu.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;「轻氧」&lt;/a&gt; 的Web版本。项目的技术栈主要使用了Express + MongoDB(leancloud)作为后端，Vue2.0 + Vue
    
    </summary>
    
      <category term="Web开发" scheme="http://www.ruanjiawei.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Vue" scheme="http://www.ruanjiawei.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>美化console.log</title>
    <link href="http://www.ruanjiawei.com/2016/10/18/colorful-console-log/"/>
    <id>http://www.ruanjiawei.com/2016/10/18/colorful-console-log/</id>
    <published>2016-10-18T11:05:11.000Z</published>
    <updated>2016-10-18T11:11:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，控制台的各种打印日志的方法，如log，info，error和warn等，都过于简单，满足不了我们的需求。尤其是，当你通过在浏览器的控制台输出大量的日志进行调试一个很庞大的应用的时候。 </p>
<a id="more"></a>
<p>在Firebug中，你可以通过在信息中加入“％c”前缀标记，在日志信息中应用你自己的样式。并且，Firebug在log方法中还提供了一个css样式字符串作为第二个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;%c the green hulk got mad!&apos;, &apos;color: green; font-weight: bold;&apos;);</div></pre></td></tr></table></figure></p>
<p><img src="https://coderwall-assets-0.s3.amazonaws.com/uploads/picture/file/1144/Screen_shot_2013-01-16_at_5.21.59_PM.png" alt="firebug-colorful-console"> </p>
<h3 id="特别的样式"><a href="#特别的样式" class="headerlink" title="特别的样式"></a>特别的样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;%c a colorful message&apos;, &apos;background: green; color: white; display: block;&apos;);</div></pre></td></tr></table></figure>
<p><img src="https://coderwall-assets-0.s3.amazonaws.com/uploads/picture/file/1143/Screen_shot_2013-01-16_at_5.20.44_PM.png" alt="log-pic-2"> </p>
<h3 id="加强版"><a href="#加强版" class="headerlink" title="加强版"></a>加强版</h3><p>你可能想为日志方法创建属于自己的样式集，在你的应用中给每一个组件／模块指定一个颜色，以使每一次一个特定颜色的信息出现的时候，你就知道这是哪个相关的部分。<br><img src="https://coderwall-assets-0.s3.amazonaws.com/uploads/picture/file/1146/Screen_shot_2013-01-16_at_5.40.03_PM.png" alt="taking it further"> </p>
<h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3?"></a>CSS3?</h3><p>是的，你可以给你的日志信息加一些很棒的CSS3的样式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> styles = [</div><div class="line">    <span class="string">'background: linear-gradient(#D33106, #571402)'</span></div><div class="line">    , <span class="string">'border: 1px solid #3E0E02'</span></div><div class="line">    , <span class="string">'color: white'</span></div><div class="line">    , <span class="string">'display: block'</span></div><div class="line">    , <span class="string">'text-shadow: 0 1px 0 rgba(0, 0, 0, 0.3)'</span></div><div class="line">    , <span class="string">'box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4) inset, 0 5px 3px -5px rgba(0, 0, 0, 0.5), 0 -13px 5px -10px rgba(255, 255, 255, 0.4) inset'</span></div><div class="line">    , <span class="string">'line-height: 40px'</span></div><div class="line">    , <span class="string">'text-align: center'</span></div><div class="line">    , <span class="string">'font-weight: bold'</span></div><div class="line">].join(<span class="string">';'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'%c a spicy log message ?'</span>, styles);</div></pre></td></tr></table></figure>
<p><img src="https://coderwall-assets-0.s3.amazonaws.com/uploads/picture/file/1155/Screen_shot_2013-01-17_at_3.02.35_PM.png" alt="css3-console"> </p>
<h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><ul>
<li>目前你可以在Firefox中使用Firebug插件实现</li>
<li>在金丝雀版（译者注：这是开发者版）Chrome的开发者工具中可以使用，同时，在Chrome稳定版也很快可以实现（译者注：经测试，最新版（53.0.x或更新版本）已经支持）。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，控制台的各种打印日志的方法，如log，info，error和warn等，都过于简单，满足不了我们的需求。尤其是，当你通过在浏览器的控制台输出大量的日志进行调试一个很庞大的应用的时候。 &lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://www.ruanjiawei.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web" scheme="http://www.ruanjiawei.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>花地河边上最后的晚餐</title>
    <link href="http://www.ruanjiawei.com/2016/09/09/before-leaving-vip/"/>
    <id>http://www.ruanjiawei.com/2016/09/09/before-leaving-vip/</id>
    <published>2016-09-09T15:14:23.000Z</published>
    <updated>2016-09-09T17:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新了博客的关于页面的个人履历，脑海里回放着这一年里发生的点点滴滴，忍不住要动手码几下，Mark一下最近发生的事情。   </p>
<p>在荷香居和前项目组的同事们吃完最后一顿饭，意味着我即将离开这个陪伴了我将近一年的公司，跟这些可爱的同事们做最后的告别。也许未来我还会经常回芳村找这些可爱的人，但是那时，我将是以朋友的身份出现，而不会再是同事。 </p>
<p>离别总是伤感的，好在这个结果给了我一个多月的时间去适应，以至于在今晚还能故作淡定地在饭局中谈笑风生。在这一个多月里，有过无数的挣扎，前期主要是为了留下，到中期是对vip的失望，以至到最后执意要离开。</p>
<p>七月底从阳江回到广州之后，大家都得面对新出路的问题。记得七月下旬的时候，Cindy跟我说，要给我在运营中心换一个NB的岗位。我说我现在很好啊，为什么要换呢，虽然运营中心确实比我们项目组NB，但我干得开心啊。再者，那时候老大还埋了一个好消息，大概是我们的项目组要腾飞了，因为有特卖会给我们做推广。呵呵，讽刺，几天后，我们接到消息说我们的项目组要被关停了。</p>
<p>Cindy过来调侃我，大意是“你看吧，傻逼了吧，现在你还是得来运营中心，我罩你“。但事实是，后来，很多事情完全不按照常理出牌，Cindy也罩不住我了。  </p>
<p>我过去运营中心面试的时候，那几个面试官都挺有趣，也聊得不错。事情到这里的时候，我已经起码有三个选择了，一个是留在多APP，一个是去VIS，一个是去运营中心。那时候我就在彷徨，哎，换部门了不知道是不是好事等等，但后来的风云突变告诉我，我还是太年轻。</p>
<p>先是多APP没有编制，然后是老大不去VIS了，最后我只能让Cindy走运营中心的流程。一切到这里好像问题都不大了，但期间经历了测试两个孩子的荒唐经历，就感觉这一切都有很大的变数。果不其然，一周多后，Cindy告诉我没有编制了，流程白走，我又被打回了S项目，苍天。</p>
<p>这时候形势已经有些不对劲了。从这个时候开始，我开始陆续向外面投递一些简历，YY、UC、网易、CVTE、爱范儿、铂涛旅行等。然而这个节点，外面的形势也颇为严峻，大多数都是要3年以上工作经验的，而我这个才一年工作经验的小萌新显得极为另类。YY、UC陆陆续续地把我的简历置为不合适，我已经感觉我的好日子要到头了。  </p>
<p>这时候，老大联系的VIS听说有编制，我跟顺文在某个下午过去，听那个每天下午两点来上班，5点出头就下班的前端老大，滔滔不绝地讲了一个多小时，期间我们基本插不了嘴，最后告诉我们说，这边的编制一个也行，两个也行，让我们回去考虑。结果两天后告诉我们说只有一个编制，好吧，虽说我也不打算去做一些后台相关的业务，但感觉又是一个坑。  </p>
<p>正好，这时候，外面的面试电话一个一个地打进来了。短短几天，我迅速收割了CVTE和爱范儿的offer，虽然这些offer都不见得多理想，但是起码待遇上已经完全没问题了。很快，网易给我电话了，让我有时间去网易大厦面试－－对于这个电话，我是喜出望外的，因为网易一直是我崇拜的一家技术性的互联网公司。</p>
<p>网易游戏的岗位是高级前端开发工程师，岗位需求是3年以上工作经验。在网易大厦面试的时候，面试官一开口就提醒我，希望我尽可能地把自己表现出来，因为这个岗位很少会叫一年工作经验的人过来面试的。这一波提醒搞得我有点紧张，以至在后来的一个多小时的面试中，问题回答得有些胆怯，部分问题回答得比较浅，但是整个面试下来，我出门的时候，自我感觉还是良好的。 </p>
<p>从网易游戏回来等二面，等了一个将近10天，我已经感觉没戏了。某个周五，Cindy让我去面试运营中心的一个岗位，面试感觉都挺好，那两个前端对我也挺满意，但他们老大说，他们想招一个资深的过来带队，ok，我知道又黄了，行，这时候我是真的不想留下来了。正好从总部出来的时候，网易打电话约我进行第二轮面试。 </p>
<p>第二波又面了三轮加一次笔试，累成渣。面完之后，我就感觉整体问题不大了，他们的hr－Joanna简单地跟我聊了一些无关紧要的事情后，告诉我这几天会给我消息。插一句，网易的hr真是学霸，Joanna是英国爱丁堡大学的海龟，感觉网易里真是卧虎藏龙。  </p>
<p>三天后，我在深圳。Joanna说我的offer没问题，让我过去谈谈薪水的问题。当时觉得“哎呀这个屌不错啊”，劳资再不用因为才一年工作经验被VIP除了Cindy之外的HR无视了（插一句，中间我有把我简历给别的HR，但他们都不鸟我啊～ 忧桑）。  </p>
<p>在深圳的两天的时间里，我去了京东面试。去面试之前，其实我是完全没打算去京东的，一来我没打算去深圳，二来我也更偏向于去网易－－毕竟是我心目中的偶像级的巨头。但是面试之后，我犹豫了，他们做的东西感觉比我现在做的业务有趣多了。再者，跟Joanna谈完待遇的时候，回来想了一下，感觉待遇跟我预期的还是有些差距，再结合那天晚上跟大学室友辰宇的聊天，我已经更倾向于京东了。  </p>
<p>后来，Cindy让我去唯品生活，面了，无感，虽说他们那边也很热忱地希望我过去，Cindy也希望我能留下来，但是，我去意已决，唯有以后有机会，再回到这里，看看这里的花花草草以及可爱的同事们。</p>
<p>但是离开广州去深圳，最难舍的还是以前项目组的小可爱们，尤其是7个人的小分队的小伙伴。</p>
<p>说说毛毛吧，哎，挺有趣的一个小伙伴。一个人去了一个新部门，从前端转到测试，本来是个好事，毕竟能做自己喜欢做的事情，但是不想，去了不到两周就自己辞职了，连自己下一步该干什么还在犹豫和彷徨，更重要的是，经过这么一折腾，两个月的工资就打了水漂。在7人小分队开小灶的时候，我们都能在你身上找到笑点，简直就一谐星。虽然你跟我说希望我留在广州，但是我觉得我去哪不重要，况且广深就半个小时的高铁路程，相信我去了哪里，未来都有大把相聚的机会～  </p>
<p>岛主，传闻家里有几座岛，还承诺给我们小分队一人一座，但是还是这么励志地出来写代码。跟岛主熟络，还是因为他带我写iOS，虽说我在项目组里一起写iOS应用的时间不长，但是在那两个月里，我iOS的水平突飞猛进，很大程度上得益于岛主的帮助。记得跟岛主深交，还是从阳江海滩开始的，然后开始一起去顺文家打牌，然后在最近的半个月里，天天坐在一起讨论人生，讨论创业等等。岛主很有趣，也很淡然，在我在外面为面试奔波的时候，岛主在认真地看资料，写代码，一副颇为淡定地样子，叫他投简历，也是一拖再拖～嗯，这份淡然，很值得我学习～ 峰回路转，最近iOS的行情并不好，未来，我将带你写H5，带你走向人生巅峰～   </p>
<p>顺文土豪，在广州一个人住三房。每次我们要去他家打牌，他都是那么热情地欢迎我们几个小婊砸，完全不介意我们每次都把他家搞得一团糟。在公司，由于我们都是前端，彼此之间接触也比较多，在他身上也学习到了很多跟技术相关的东西，非常优秀的一个好盆友，希望在未来，我们几个能继续约约约～  </p>
<p>其他还有几个就不多说了，再说就泪汪汪了～  </p>
<p>其实在最后想着重感谢老大－－家昕。在这将近一年的时间里，跟着家昕，我是一分委屈都没有受过，我相信我们组里的任何一个人都是。在这样的团队里，老大一点架子都没有，跟着我们一起开玩笑，跟我们聊基本一致的话题，非常有融入感。而且在这一年中，他也让我尝试了很多我想要深入接触的东西，比如iOS开发等等。在我去外面面试的时候，他也鼓励我，要是能去网易或者什么其他好的公司，不要犹豫，尽管辞职。今天晚饭结束出来的时候，老大和我说有空再聚什么的时候，lily说你们要不要抱一抱，其实我是真想拥抱一下的，但鉴于当时人那么多，怕忍不住伤感落泪，刚好我叫的滴滴这时候又过来了，说了一句拜拜就匆忙告别了～   </p>
<p>要感谢的人好多好多，比如lily，作为pmo，像个保姆一样，照顾着我们，实在有太多想说的话，但是话到嘴边，实在说不出口了，男人，就是闷骚～</p>
<p>希望在未来，还能回到当初在一起的日子～  </p>
<p>2016.09.09 深夜</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更新了博客的关于页面的个人履历，脑海里回放着这一年里发生的点点滴滴，忍不住要动手码几下，Mark一下最近发生的事情。   &lt;/p&gt;
&lt;p&gt;在荷香居和前项目组的同事们吃完最后一顿饭，意味着我即将离开这个陪伴了我将近一年的公司，跟这些可爱的同事们做最后的告别。也许未来我还会经常
    
    </summary>
    
      <category term="躁动的心" scheme="http://www.ruanjiawei.com/categories/%E8%BA%81%E5%8A%A8%E7%9A%84%E5%BF%83/"/>
    
    
      <category term="mood" scheme="http://www.ruanjiawei.com/tags/mood/"/>
    
  </entry>
  
  <entry>
    <title>苹果官方iOS入门教程译版之第三章：Build a Basic UI</title>
    <link href="http://www.ruanjiawei.com/2016/08/07/Start-Developing-iOS-Apps-Swift-3/"/>
    <id>http://www.ruanjiawei.com/2016/08/07/Start-Developing-iOS-Apps-Swift-3/</id>
    <published>2016-08-07T01:16:00.000Z</published>
    <updated>2016-08-08T07:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这章会带你熟悉用来写应用的工具－－Xcode。你将会熟悉Xcode中的项目结构，学会如何在导航之间跳转以及学会使用基本的项目组件。这一整章中，你将会开始为FoodTracker应用创建一个简单的用户接界面（UI,user interface），并且让它在模拟器中显示出来。当你完成这些之后，你的应用（app）将会像下面这样：<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/2_sim_finalUI_2x.png" alt="result_UI">  </p>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>在本章的最后，你将会学习到以下知识：</p>
<ul>
<li>在Xcode中创建一个工程</li>
<li>认识在创建Xcode项目时，主文件中的样板方法</li>
<li>在项目中打开和切换文件</li>
<li>在模拟器中运行应用</li>
<li>在Storyboard中增加、移除和调整用户界面</li>
<li>使用属性检查（Attributes inspector）在Storyboard中编辑用户界面元素的属性</li>
<li>使用轮廓视图（outline view）浏览和重新排列storyboard中的用户界面</li>
<li>使用预览助手编辑器（Preview assistant editor）预览storyboard中的用户界面</li>
<li>使用自动布局（Auto Layout）布局能够自动适应用户设备尺寸大小的用户界面</li>
</ul>
<h3 id="创建一个新工程"><a href="#创建一个新工程" class="headerlink" title="创建一个新工程"></a>创建一个新工程</h3><p>Xcode内置了几个应用模版，如游戏、基于触摸的导航应用和基于表格视图的应用，用来辅助开发普遍类型的iOS应用。这些模版大多数都有预先配置好的用户界面和源代码文件。在本章中，你将会从最基本的模版－－单页应用开始。  </p>
<p><strong>创建一个新工程的步骤：</strong>  </p>
<ol>
<li>在/Application目录中打开Xcode（这将会出现Xcode的欢迎界面）<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/Xcode_welcome.png" alt="Xcode_welcome"><br>如果你的界面不是欢迎界面的样子，不用担心－－你的Xcode可能在之前创建或打开过项目。你只需要在下一步中使用菜单选项即可创建工程。 </li>
<li>在欢迎界面中，点击“Create a new Xcode project”（或者选择 File &gt; New &gt; Project）。Xcode将会打开一个新的窗口，并且显示一个对话框。在这个对话框中，选择一个模版。  </li>
<li>在对话框左边的iOS区域中，选择Application。</li>
<li>在对话框的主区域里，点击Single View Application，然后点击Next。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/Chapter2_create_project_1.png" alt="Create_project_1"></li>
<li><p>在显示的对话框中，使用下面的值命名你的应用，并为你的应用选择其它合适的选项。 </p>
<ul>
<li>Product Name: FoodTracker<br>Xcode将会使用你输入的这个名字命名你的工程和应用。</li>
<li>Organization Name: 你的组织的名字或者你自己的名字。你可以把这项留空。</li>
<li>Organization Identifier: 你的组织的标识，如果你有的话，就如实填写；如果没有，可以使用com.example。</li>
<li>Bundle Identifier：这个值是基于你的Product Name和Organization identifier自动生成的。</li>
<li>Language：Swift</li>
<li>Devices： Universal<br>一个通用（Universal）的应用可以同时在iPhone和iPad上运行。</li>
<li>Use Core Data：不选。</li>
<li>Include Unit Tests： 选上。</li>
<li>Include UI Test：不选。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/Chapter2_create_project_2.png" alt="create_project_2"></li>
</ul>
</li>
<li><p>点击Next    </p>
</li>
<li>在显示出来的对话框中，选择你要保存这个工程的位置，然后点击Create。<br>Xcode将会在工作区窗口（workspace window）中打开你的新工程。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/Chapter2_create_project_3.png" alt="create_project_3"></li>
</ol>
<p>在工作区窗口中，你有可能会看到这样的一条警告消息：“No code signing identities found.”。这条警告的意思是，你还没有为iOS开发安装Xcode，但是不用担心，你可以在无视它的情况下完成这些课程。 </p>
<h3 id="熟悉Xcode"><a href="#熟悉Xcode" class="headerlink" title="熟悉Xcode"></a>熟悉Xcode</h3><p>Xcode涵盖了所有你想创建一个应用所需要的东西。它不仅帮你组织好创建一个应用所需要的代码，还为代码和视图元素提供了编辑器，允许你打包你的应用，同时还包含了一个强大的集成调试器。  </p>
<p>要熟悉Xcode工作区中的主要的区域，你需要花费一点时间。你将会在整个教程中使用到下图窗口中标记的区域。不要这些东西打击，因为当你需要使用到的时候，每一个区域都会做详细的描述的。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/chapter2_Xcode_outline.png" alt="Xcode_outline">  </p>
<h3 id="运行模拟器"><a href="#运行模拟器" class="headerlink" title="运行模拟器"></a>运行模拟器</h3><p>因为你是基于Xcode的模版建立项目的，所以基本的应用环境会自动地为你设置。即便你还没有写任何的代码，你也可以在没有额外的配置的情况下编译和运行你的单页应用模版。  </p>
<p>使用Xcode中的模拟器（Simulator）可以运行你的app。模拟器能够让你知道当应用在实际设备中运行时，整个应用的外观以及行为。  </p>
<p>模拟器能模拟不同的硬件设备类型－－不同屏幕大小的iPad和iPhone等。所以你可以在你开发的平台的设备中模拟你的应用。在本教程中，使用iPhone6作为模拟器。  </p>
<p><strong>运行你的app的步骤：</strong>  </p>
<ol>
<li>在Xcode工具栏的弹出式Scheme菜单中，选择iPhone6.<br>这个弹出式的Scheme菜单能让你选择各种模拟器或设备，以运行你的app。确保你选择的是iPhone6模拟器，而不是iOS Device（设备）。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/run_simulator_1.png" alt="step1"></li>
<li>点击位于Xcode工具栏左上角的 Run 按钮。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/run_simulator_2.png" alt="step2"><br>除此之外，你也可以选择 Product &gt; Run (或者使用键盘Command-R)来运行。<br>如果你是第一次运行app,Xcode会询问你是否愿意在你的Mac上启用开发者模式。开发者模式(developer mode)允许Xcode在访问某一个特性的时候，不需要每次都输入你的密码。你可以        决定是否启用开发者模式，在提示框中做出你的选择。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/run_simulator_3.png" alt="step2"><br>如果你选择了不启用开发者模式，你可能会在之后被询问密码。本教程中假定开发者模式是开启的。</li>
<li>在Xcode工具栏中查看编译完成的过程。<br>Xcode会在工具栏中间的活动视图（Activity viewer）中显示编译过程的信息。   </li>
</ol>
<p>Xcode编译项目完成后，会自动启动模拟器。第一次启动的时候，可能需要花费一点时间。  </p>
<p>模拟器在你指定的iPhone模式下打开。在模拟的iPhone窗口，模拟器将会启动你的app。在app完成启动之前，你将会在启动窗口中短暂地看到你的app的名字，FoodTracker。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/app_init_launch.png" alt="app_init_launch">  </p>
<p>然后，你应该会看到像下面这样的界面。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/app_blank.png" alt="app_blank">  </p>
<p>现在，这个单页应用模版还没有做什么工作－它只是显示一个白屏。其它模版会有更复杂的行为。在扩展你的app的之前，理解一个模版的使用是非常重要的。在没有做任何修改之前运行你的app，是开始开发应用时的一个很聪明的做法。  </p>
<p>通过选择 Simulator &gt; Quit Simulator (或者按下键盘Command-Q)退出模拟器。  </p>
<h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><p>这个单页应用模版附带了一些源代码文件来建立应用环境。首先，看一看AppDelegate.swift文件。  </p>
<p><strong>查看AppDelegate.swift文件源码</strong>  </p>
<ol>
<li>确保工程导航在导航区是打开的。<br>工程导航(project navigator)显示了你工程的所有文件。如果工程导航没有打开，        则点击最左边的导航条按钮。(除此之外，还可以选择 View &gt; Navigators &gt; Show         Project Navigator)<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/review_source_code_1.png" alt="step1"></li>
<li>如果必要，通过点击工程导航栏里的FoodTracker文件夹旁边的三角形来打开        FoodTracker文件夹。  </li>
<li>选择AppDelegate.swift文件。<br>Xcode将会在窗口的主编辑区中打开该文件的源代码。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/review_source_code_2.png" alt="step2"><br>除此之外，你还可以通过双击AppDelegate.swift文件，在新的窗口中打开它。  </li>
</ol>
<h3 id="App-Delegate-应用代理-源文件"><a href="#App-Delegate-应用代理-源文件" class="headerlink" title="App Delegate(应用代理)源文件"></a>App Delegate(应用代理)源文件</h3><p>AppDelegate.swift文件包含两个主要的功能：  </p>
<ul>
<li>它在你的app中创建了入口和一个分发输入事件的运行循环（run loop）。这个工作是通过UIApplicationMain属性（@UIApplicationMain）完成的；这个属性位于该文件内容的上方。UIApplicationMain创建了一个应用对象（application object）管理app生命周期，同时也会创建一个应用代理（app delegate）对象—这个对象在下面会作描述。 </li>
<li>它创建了一个描述这个app代理对象的蓝图的AppDelegate类。App代理会创建一个绘制app内容和提供响应app内状态改变的窗口，而AppDelegate类是你写定制的app层级代码的地方。 </li>
</ul>
<p>AppDelegate类包含一个独立地属性：window。通过这个属性，app代理能够跟踪绘制了所有app内容的窗口。Window属性是一个可选值，也就是说在某些情况下，它可能没有值（nil）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var window： UIWindow？</div></pre></td></tr></table></figure></p>
<p>AppDelegate类同样包含了一些重要方法的实现模板。这些预定义的方法允许应用对象（application object）和app代理对话。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool</div><div class="line">func applicationWillResignActive(application: UIApplication)</div><div class="line">func applicationDidEnterBackground(application: UIApplication)</div><div class="line">func applicationWillEnterForeground(application: UIApplication)</div><div class="line">func applicationDidBecomeActive(application: UIApplication)</div><div class="line">func applicationWillTerminate(application: UIApplication)</div></pre></td></tr></table></figure>
<p>在app状态改变的时候—比如，app启动、转至后台运行、终止等，应用对象会调用app代理中的响应方法，使得它能够有机会做出合适的响应。你不需要做任何特别的事情来确保这些方法在正确的时间调用—应用对象会为你做这部分的处理工作。  </p>
<p>每一个这些自动实现的方法都有一个默认的行为。如果你保持这些模板实现为空或者从AppDelegate类中把它们删除，那么在这些方法调用的时候，你都会得到它们默认的行为。在这些方法调用的时候，使用这些方法模板来增加的自定义代码也会得到执行。在本教程中，你不会使用到任何自定义的app代理代码，所以你不必改动AppDelegate文件。 </p>
<h3 id="视图控制器源文件"><a href="#视图控制器源文件" class="headerlink" title="视图控制器源文件"></a>视图控制器源文件</h3><p>单页应用模板还有另外一个源码文件：ViewController.swift。在工程导航中选择ViewController.swift可以查看该文件。 </p>
<p><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/view_controller_source_file.png" alt="viewController"> </p>
<p>这个文件定义了一个自定义的UIViewController的子类，名字为ViewController。现在，这个类只是简单地继承了UIViewController中定义的行为。要重写或者扩展这些行为，你需要重写在UIViewController中定义的方法（正如你在ViewController.swift文件中看到的viewDidLoad()和didReceiveMemoryWarning()方法所做的一样），或者实现你自定义的方法。   </p>
<p>虽然这些模板中存在didReceiveMemoryWarning()方法，但是在本教程中，你不需要对其做任何的实现，所以你尽管删掉它。  </p>
<p>到此，你的ViewController.swift代码看起来应该像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">class ViewController: UIViewController &#123;</div><div class="line"></div><div class="line">override func viewDidLoad() &#123;</div><div class="line">super.viewDidLoad()</div><div class="line">// Do any additional setup after loading the view, typically from a nib.</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在稍后的教程中，你将会开始在这个源码文件中写代码。 </p>
<h3 id="打开你的Storyboard"><a href="#打开你的Storyboard" class="headerlink" title="打开你的Storyboard"></a>打开你的Storyboard</h3><p>你即将开始在你app的storyboard中进行工作。Storyboard是你app的用户界面的可视化呈现工具，它能展示内容界面和在内容界面之间的切换关系。使用storyboard可以对app进行布局以驱动你的app。在你构建界面的时候，你将会清晰地看到你正在构建的东西，得到对于你正在做的东西的即时的反馈，同时能够马上看到你对用户界面的更改。   </p>
<p><strong>步骤：打开你的storyboard</strong> </p>
<ul>
<li>在工程导航中，选择Main.storyboard。<br>Xcode会在界面设计器（Interface Builder）中打开storyboard。界面设计器是Xcode的可视化界面编辑器，位于编辑区中。Storyboard的背景是一块画布（canvas）。你可以使用这个画布增加和布局UI元素。<br>你的storyboard看起来应该像这样： </li>
</ul>
<p><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/storyboard_default.png" alt="storyboard"> </p>
<p>这时候，你的app中的storyboard包含了一个场景（scene），这个场景展示了你app中一屏幕的内容。画布中，指向场景左边的箭头是storyboard的入口（entry point），其表示当app启动的时候，这个场景是第一个被加载的。现在，你在画布中看到的场景包含了一个被视图控制器管理的单个视图。你很快将会学习到更多关于视图和视图控制器的作用方面的知识。  </p>
<p>当你在iPhone6模拟器中运行你的app的时候，该场景中的视图就是你在设备界面中看到东西。但是，当你在画布中看这个场景的时候，你会意识到它没有iPhone6屏幕的准确尺寸。这是因为在画布中的场景是通用的，它能够适用于所有的设备和方向。你可以使用这个特性创建一个自适应的界面—自适应界面能够根据当前的设备和方向，自动地调整界面以使其友好地显示。  </p>
<h3 id="创建基础的UI"><a href="#创建基础的UI" class="headerlink" title="创建基础的UI"></a>创建基础的UI</h3><p>现在是时候构建基本的界面了。你将会为你的食谱app—FoodTracker创建一个UI，它能允许你在你的app上添加一条食谱。  </p>
<p>Xcode提供了一个对象库，通过这个库你可以添加一个storyborad文件。这个库中的一部分是能在用户界面中显示的元素，比如按钮（buttons）和文本框（text fields）。另外一部分如视图控制器（view controllers）和手势识别器（gesture recognizers）只是定义你的app的行为而不会在屏幕中显示。 </p>
<p>在UI中显示的元素就是总众所周知的视图(views)。视图为用户显示需要的内容，其是构建你的UI的基础块，并以一种清晰的、优雅的、实用的方式呈现你的内容。视图有很多内置的实用的行为，包括在屏幕中显示它们自身，以及响应用户的输入。</p>
<p>在iOS中，所有的视图对象都是UIView或者其子类。很多UIView的子类在外观和行为上是高度定制的。在你的场景（scene）中，从添加一个UIView子类的文本框（UITextField）开始你的构建工作。 文本框能够让用户输入一段单行的文本，而这段文本将会作为你食谱的名字。 </p>
<p><strong>添加一个文本框到你的场景中</strong>  </p>
<ol>
<li>打开对象库(Object library)。<br>对象库位于Xcode右侧工具区的下方。如果你没有看到对象库，可以点击库选择条下从左算起的第三个按钮。（另外一种方式：选择 View &gt; Utilities &gt; Show Object Library.）<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/object-library.png" alt="object library"><br>在出现的列表中，显示了每一个对象的名字，描述和可视化的图标。  </li>
<li>在对象库中，在筛选区输入text field快速查找文本框对象。    </li>
<li>从对象库中拖动一个文本框对象到你的场景（scene）中。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/textfield-drag.png" alt="textfield drag"><br>如果有必要，通过选择 Editor &gt; Canvas &gt; Zoom 来进行缩放。</li>
<li>拖动文本框使其位于场景的上半部分，并使其和左边界对齐。<br>当你看到如图所示的效果的时候，停止拖动。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/textfield-place.png" alt="textfield-place"><br>蓝色的布局辅助线能帮助你放置文本框。布局辅助线只有当你拖动或者改变对象尺寸的时候才会出现；当你释放了文本框的拖动的时候，这些辅助线会消失。</li>
<li>如果有必要，可以点击文本框以显示用于调整尺寸的控制点。<br>你可以通过拖动文本框的调整尺寸的控制点来实现对UI的尺寸调整。控制点位于元素的边框上，外观上是一些白色的小正方形。当你选择了文本框的时候，这些白色的小正方形就会出现。在这种情况下，文本框应该已经选上了，因为你刚刚才把它拖动完成。如果你的文本框像下面这个一样，你就可以对它进行调整大小了；否则，你应在画布上先选上它。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/textfield-resizehandles.png" alt="textfield-resizehandles"> </li>
<li>调整文本框的左右边界，直到你看到三条垂直方向的布局辅助线：左对齐，水平居中对齐，右对齐。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/textfield-finalsize.png" alt="textfield-finalsize"><br>虽然你已经在场景中放置好文本框了，但是对于这个文本框应该输入什么内容，还没有任何的指示提供给用户。使用文本框的占位符（placeholder）可以提示用户输入一个新食谱的名字。  </li>
</ol>
<h3 id="配置文本框占位符文本"><a href="#配置文本框占位符文本" class="headerlink" title="配置文本框占位符文本"></a>配置文本框占位符文本</h3><ol>
<li>选中文本框后，打开工具去的属性检查面板。<br>当你点击了选项条中从左到右算起的第四个按钮之后，就会出现属性检查面板，它能让你编辑storyboard中对象的属性。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/inspector-attributes.png" alt="inspector-attributes"></li>
<li>在属性检查面板中，找到 Placeholder 标签的区域，输入“Enter meal name”。</li>
<li>按下Return，在文本框中就会显示新的占位符文本。</li>
</ol>
<p>现在，你的场景应该像下面这样：<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/textfield-withplaceholder.png" alt="textfield-withPlaceholder">  </p>
<p>当你在编辑文本框的属性的时候，你还可以在用户选择文本框的时候，更改系统默认键盘。 </p>
<h3 id="配置文本框对应的键盘类型"><a href="#配置文本框对应的键盘类型" class="headerlink" title="配置文本框对应的键盘类型"></a>配置文本框对应的键盘类型</h3><ol>
<li>确保文本框仍在选中状态。</li>
<li>在属性检查面板中，找到Return Key标签所在的域，选择 Done。<br>把它改成 Done 之后，这个更改能让键盘上的 Return 键更加突出。</li>
<li>在属性检查面板，勾选上 Auto-enable Return Key。<br>这个更改会让文本框在用户输入文本之前，禁用Done键，确保用户不会输入一个空的食谱名字。 </li>
</ol>
<p>接下来，添加一个标签(UILabel)到场景的上方。标签是没有交互的，它只是单纯地在UI中显示静态的文本。为了帮助你理解如何定义在UI中元素的交互，你将会让这个标签以使其显示用户在文本框中输入的内容。这是一个很好的方法，用以检测文本框正确地处理用户的输入。 </p>
<h3 id="在你的场景中添加一个标签"><a href="#在你的场景中添加一个标签" class="headerlink" title="在你的场景中添加一个标签"></a>在你的场景中添加一个标签</h3><ol>
<li>在对象库的搜索框中，输入label以快速查找Label对象。</li>
<li>从对象库中，拖动label对象到你的场景中。</li>
<li>拖动标签使其位于文本框的上方并使其向左对齐。<br>当你看到像下面这样的效果时，停止拖动。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/label-place.png" alt="label-place"></li>
<li>属性这个标签，并输入Meal Name。</li>
<li>按下Return键，标签中就会显示新的文本。 </li>
</ol>
<p>你的场景应该像下图这样：<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/label-rename.png" alt="label-rename"></p>
<p>现在，在你的UI中添加一个按钮(UIButton)。按钮是可交互的，所以用户可以点击它并触发你定义的行为。稍后，你将会创建一个行为用以重设标签的值为默认值。  </p>
<h3 id="在你的场景中添加一个按钮"><a href="#在你的场景中添加一个按钮" class="headerlink" title="在你的场景中添加一个按钮"></a>在你的场景中添加一个按钮</h3><ol>
<li>在对象库的搜索框中，输入 button 以快速地查找Button对象。</li>
<li>从对象库中拖动一个Button对象到你的场景中。</li>
<li>拖动该按钮对象，使其位于文本框的下方，并使其左对齐。<br>当你看到像下面这样的效果时，停止拖动。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/button-place.png" alt="button-place"></li>
<li>双击该按钮，并输入Set Default Label Text。</li>
<li>按下Return键，按钮中就会显示新的文本。  </li>
</ol>
<p>至此，你的场景应该像下面这样：<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/button-rename.png" alt="button-rename"></p>
<p>理解你在场景中添加的元素如何布局是很有用的。通过结构图，查看你在场景中所添加的UI元素。  </p>
<h3 id="查看结构图"><a href="#查看结构图" class="headerlink" title="查看结构图"></a>查看结构图</h3><ol>
<li>在你的storyboard中，找到结构视图切换按钮。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/outlineview-toggle.png" alt="outline-toggle"></li>
<li>如果结构视图已经折叠起来，可以点击切换按钮以展开结构视图。<br>你可以根据需要，通过这个切换按钮以折叠或展开结构视图。 </li>
</ol>
<p>结构视图位于画布的左边，它展示了你的storyboard中对象的结构层次。你应该能看到刚刚添加到storyboard中的文本框，标签，和按钮。但是，为什么你添加到其中的元素被包含在view中？也就是说，在另外的一个视图中？ </p>
<p>视图不仅仅在屏幕中显示它们自身，它们还可以响应用户的输入，可以作为其它视图的容器。视图在层次结构中的排列称为视图层次（view hierarchy）。视图层次定义了视图与视图之间的关系。在视图层次内部，被另外一个视图包含的视图称为子视图（subview），而包含别的视图的视图称为这些视图的父视图。一个视图可以有多个子视图，而只能拥有一个父视图。   </p>
<p><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/outlineview.png" alt="outlineview"> </p>
<p>通常来说，每一个场景会有自己独有的视图层次。每一个视图层次的上方是内容视图（content view）。在上图的场景中，内容视图是一个View，它是视图控制器的顶层视图。文本框，标签和按钮是内容视图的子视图。你放置到场景中所有其它的视图都将会是这个内容视图的子视图（尽管它们本身可以被包含在其它子视图中）。 </p>
<h3 id="预览界面"><a href="#预览界面" class="headerlink" title="预览界面"></a>预览界面</h3><p>周期性地预览你的app，确保所有的东西都像你期望的那样。你可以使用辅助编辑器（assissant editor）预览app界面。辅助编辑器是一个备用的编辑器，其跟主界面并排地显示。 </p>
<p><strong>预览界面步骤</strong>  </p>
<ol>
<li>在Xcode中，点击位于右上角工具条中的Assisstant按钮，以打开辅助编辑器。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/assistant-editor-toggle.png" alt="assistant-editor-toggle"></li>
<li>如果需要更多的工作空间，你可以通过点击在Xcode工具栏中的Navigator和Utilities按钮隐藏工程导航栏和工具区。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/navigator-utilities-toggle-on.png" alt="navigator-utilities-toggle-on"><br>除此之外，你还可以将轮廓视图隐藏。   </li>
<li>在位于辅助编辑器上方的编辑器选项条中，把辅助编辑器从 Automatic 切换到 Preview &gt; Main.storyboard。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/assistant-editorselectorbar.png" alt="assistant-editorselectorbar"><br>如你在辅助编辑器中看到的，这个文本框看起来不大准确，它向右溢出了边界。但是，你在storyboard中看到的界面是正常的，为什么在iPhone的预览下就不正常了呢？<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/preview.png" alt="preview"><br>在这之前，你已经知道你其实创建的是一个自适应的界面，这个自适应的界面会在不同尺寸的iPhone和iPad下进行缩放。你在storyboard中看到的默认的场景展示的是你所设计的界面的通用版本。这里，你将需要指定界面在不同的屏幕尺寸下应该如何进行自适应。例如，当界面缩小到一个iPhone尺寸时，这个文本框应该也同时缩小。当界面放大到一个iPad的尺寸时，这个文本框也应该随着放大。你可以通过自动布局（Auto Layout），很简单地指定这些种类的界面。  </li>
</ol>
<h3 id="采用自动布局-Auto-Layout"><a href="#采用自动布局-Auto-Layout" class="headerlink" title="采用自动布局(Auto Layout)"></a>采用自动布局(Auto Layout)</h3><p>自动布局是一个强大的布局引擎，它能帮助你毫无压力地设计自适应的布局。你只需要为场景中需要定位的元素描述你意图，让布局引擎决定如何最完美地实现你的意图。你将会使用约束（constraits）表达你的意图，而约束是一些布局规则，其能解释一个元素相对于另一个元素如何定位，描述尺寸大小，或者当某些东西减少了两个元素的可用空间的时候，这两个元素应该如何缩小。  </p>
<p>和自动布局相伴而生的其中一个非常有用的工具是堆视图（stack view，UIStackView），它能辅助你处理自动布局。堆视图提供一个流线型的界面，用以在一个行或者列上布局一个视图的集合。堆视图能让你利用自动布局的能力，创建能动态适应设备方向，屏幕尺寸和任何可用空间的改变的用户界面。 </p>
<p>你可以很简单地把你现有的界面包在一个堆视图中，通过添加必要的约束使堆视图在不同的情形状下正确地显示。 </p>
<p><strong>在食谱场景中添加自动布局约束</strong> </p>
<ol>
<li>通过点击Standard按钮返回到标准编辑器中。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/standard-toggle.png" alt="standard-toggle"><br>通过点击在Xcode工具栏中的Navigator和Utilities按钮，展开工程导航和工具区。</li>
<li>在你的键盘中按下Shift键的时候，选择文本框（text field），标签（label）和按钮（button）。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-shift-select.png" alt="AL-shift-select"></li>
<li>在画布的右下角，点击 Stack 按钮。（除此之外，也可以选择 Editor &gt; Embed In &gt; Stack View）。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-stackmenu.png" alt="AL-stackmenu"><br>Xcode会这些UI元素包在一个堆视图中，把它们堆在一起。Xcode会分析你现有的布局，计算出这些元素应该在纵向堆叠，而不是横向。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-stack.png" alt="AL-stack"></li>
<li>如果有必要，可以打开轮廓视图，然后选择 Stack View 对象。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-outlineview.png" alt="AL-outlineview">   </li>
<li>在属性检查器中，在 Spacing 框中输入12，然后按下回车。<br>你将会看到这些UI元素在纵向铺展开，而这个堆视图也同样被放大了。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-stackspaced.png" alt="AL-stackspaced"></li>
<li>点击位于画布右下方的Pin，打开Pin菜单。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-pinmenu.png" alt="AL-pinmenu"></li>
<li>在“Spacing to nearest neighbor”上方，通过点击水平的两个和上面纵向的一个约束以选上它们。选上后，它们会变成红色。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-pinconstraints.png" alt="AL-pinconstraints"><br>这些约束表明了相对于左、右和顶部近邻元素的间距。在这个上下文中，近邻的情况表示最接近自身的元素的边界，这可能会是父视图，同级视图，或者是一个边距。因为“Constrain to margins”选框已经选上了，所以这个堆视图在这种情况下将会约束它的父视图的左、右和上边距，从屏幕的边界中预留少量的空间。 </li>
<li>在左右框中分别输入0，在上方框中输入60。</li>
<li>在弹出的Update Frames旁边，选择Items of New Constraints。<br>这个Pin菜单看起来应该像这样：<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-stackconstraints.png" alt="AL-stackconstraints"> </li>
<li>在Pin菜单中，点击Add 3 Constraints按钮。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-add3constraints.png" alt="AL-add3constraints"><br>这个食谱UI看起来应该像这样：<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-stackfinal.png" alt="AL-stackfinal"><br>你会发现文本框没有像之前那样伸展到场景的边缘，所以你稍后将会修复这个问题。  </li>
</ol>
<p><strong>调整食谱场景中的文本框宽度</strong>  </p>
<ol>
<li>在你的storyboard的食谱场景中，选上文本框。   </li>
<li>在画布的右下方，打开Pin菜单。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-pinmenu-2.png" alt="AL-pinmenu-2">   </li>
<li>在“Spacing to nearest neighbor”中，点击两个水平的约束以选上它们。选上后，它们会变成红色。 </li>
<li>在左右两个框中，输入0。</li>
<li>在弹出的Update Frames旁边，选择Items of New Constraints。<br>这个Pin菜单看起来应该像这样：<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-textfieldconstraints.png" alt="AL-textfieldconstraints"> </li>
<li>在Pin菜单中，点击Add 2 Constraints按钮。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-add2constraints.png" alt="AL-add2constraints">  </li>
<li>选上文本框后，在工具区中打开尺寸检查（Size inspector）。<br>当你选上检查器选条中的第五个按钮后，尺寸检查器将会出现。它能让你编辑storyboard中对象的尺寸和位置。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/inspector-size.png" alt="inspector-size"> </li>
<li>在Intrinsic Size框中，选择Placeholder。（这个框位于尺寸检查器的最下方，所以你需要滚到下方。）<br>文本框是基于它们自身的内容确定大小的，这些内容定义了它们的固有的内容尺寸（intrinsic content size）。固有的内容尺寸表明在视图中显示所有内容需要的最小尺寸。如果你需要为不容的尺寸设计一个UI，你可以指定UI元素一个占位的固有的内容尺寸。现在，这个文本框的内容是它的占位符文本，但是用户输入的实际文本可能比这个更长。 </li>
</ol>
<p>现在这个食谱场景的UI看起来应该像这样：<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-textfieldfinal.png" alt="AL-textfieldfinal"> </p>
<p>检验成果：在模拟器中运行你的app。这个文本框应该不会溢出屏幕的边界了。你应该可以点击文本框并使用键盘输入文本（如果你喜欢，可以通过按下Command－K弹出软键盘）。如果你翻转设备（command ＋ 左箭头或者command ＋ 右箭头），或者在一个不同的设备中运行app，文本框将会根据设备的方向和屏幕大小放大或者缩小文本框。注意，在横屏的时候，状态条会消失。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/sim-finalU-I2x.png" alt="sim-finalUI-12x"> </p>
<p>如果你没有得到预料中的结果，可以使用自动布局调试功能来帮助你。点击“Resolve Auto Layout Issues”图标，然后选择“Reset to Suggested Constraints”让Xcode通过一个有效的约束集来更新你的界面。或者点击“Resolve Auto Layout Issues”然后选择“Clear Constraints”以移除UI元素上所有的约束，之后再尝试一遍上面的步骤。<br><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/images/Build-a-Basic-UI/AL-resolvemenu.png" alt="AL-resolvemenu"> </p>
<p>虽然这个场景还没有太多东西，但是已经搭建了基础的用户界面和功能了。确保你的布局在一开始就是健壮和可拓展的，以保证你有一个坚实的基础来继续添砖加瓦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这章会带你熟悉用来写应用的工具－－Xcode。你将会熟悉Xcode中的项目结构，学会如何在导航之间跳转以及学会使用基本的项目组件。这一整章中，你将会开始为FoodTracker应用创建一个简单的用户接界面（UI,user interface），并且让它在模拟器中显示出来。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.ruanjiawei.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://www.ruanjiawei.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>苹果官方iOS入门教程译版之第二章：Learn the Essentials of Swift</title>
    <link href="http://www.ruanjiawei.com/2016/07/30/Start-Developing-iOS-Apps-Swift-2/"/>
    <id>http://www.ruanjiawei.com/2016/07/30/Start-Developing-iOS-Apps-Swift-2/</id>
    <published>2016-07-29T16:16:00.000Z</published>
    <updated>2016-08-08T07:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>你的第一门课程将会以playground的形式呈现。如第一章所说，playground是一种文件类型，它能让你在其中修改你的Swift代码，并能立即看到代码的运行结果。Playgrounds对于Swift学习和尝试是很棒的一个功能，它能帮助你加速对Swift基础概念的了解。 </p>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>在本章的最后，你将掌握以下这些：</p>
<ul>
<li>区分常量和变量</li>
<li>了解何时使用隐式和显示的类型声明</li>
<li>理解使用可选类型和可选类型绑定的优势</li>
<li>区分可选类型(optionals)和隐式解包的可选类型(implicitly unwrapped optionals)</li>
<li>理解条件语句和循环的目的</li>
<li>超过双重判断条件时使用switch语句来做条件判断</li>
<li>在条件语句中使用where来增加条件约束</li>
<li>区分函数、方法和构造器</li>
<li>区分类，结构体和枚举</li>
<li>理解继承和协议一致性(protocol conformance)的语法</li>
<li>确定隐式的类型，使用Xcode的快速帮助（quick help）快捷方式（Option-Click）查看更多的信息</li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>常量在一开始被声明之后就一直保持同样的值，而变量在声明之后可以被改变。常量意味着它是不可变的，而变量是可变的。如果你一开始就知道你的值在你的代码中就不会改变，那你应该声明它为常量而不是变量。<br>使用let创建一个常量，var创建一个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myVariable = 42</div><div class="line">myVariable = 50</div><div class="line">let myConstant = 42</div></pre></td></tr></table></figure></p>
<p>每个常量和变量在Swift中都有一个类型，但是你不必显式地把类型写出来。当你声明一个常量或者变量的时候，提供给这个常量或者变量一个值，让编译器去推断它的类型。在上面的例子中，编译器推断出myVariable是一个整型，因为它的初始值是一个整型值。这种特性叫做类型推断。一旦常量或者变量有了一个类型，那么这个类型就不能改变。</p>
<p>如果初始值提供不了足够的信息（或者没有初始值），那你需要通过在变量名之后为其指定类型，中间通过冒号分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let implicitInteger = 70</div><div class="line">let implicitDouble = 70.0</div><div class="line">let explicitDouble: Double = 70</div></pre></td></tr></table></figure></p>
<blockquote>
<p>动手操作<br>在Xcode中，试试Option-Click(译者注：按住option键再点击，本教程中所有的这种写法的操作都类似)常量或者变量的名字，查看它的推断类型。使用上面代码中的常量去动手尝试。</p>
</blockquote>
<p>值永远不会隐式地转换为另一种类型。如果你需要把一个值转换为另一种不同的类型，那你需要显式地创建一个你期望的类型的实例。在下面的例子中，你将转换一个Int类型的值为一个String类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let label = &quot;The width is &quot;</div><div class="line">let width = 94</div><div class="line">let widthLabel = label + String(width)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>动手操作<br>尝试把上面代码最后一行的String去掉。你会发现什么错误？</p>
</blockquote>
<p>还有一种更简单的方式把值转换成String类型：在圆括号中写值，并在圆括号中的开始处插入反斜杠“\”。这就是我们熟悉的字符串插值表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let apples = 3</div><div class="line">let oranges = 5</div><div class="line">let appleSummary = &quot;I have \(apples) apples.&quot;</div><div class="line">let fruitSummary = &quot;I have \(apples + oranges) pieces of fruit.&quot;</div></pre></td></tr></table></figure></p>
<p>使用可选类型处理值有可能出现值缺失的情况。可选类型的值要么包含一个值，要么就是一个表明值缺失的nil（没有值）。在值的类型后面加上问号（？）以标记该值为可选类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let optionalInt: Int? = 9</div></pre></td></tr></table></figure></p>
<p>为了从一个可选类型中得到隐含的值，你需要对它进行解包。你稍后将会学习解包可选类型，但是你可以采用最直接的方式－－用强制解包操作符号（！）来进行解包。只有在你确定隐含的值不为nil的时候，你才能用强制解包操作符来进行解包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let actualInt: Int = optionalInt!</div></pre></td></tr></table></figure></p>
<p>可选类型在Swift中是普遍的。在很多情况下，当一个值也许需要又也许不需要呈现的时候，可选类型是非常有用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myString = &quot;7&quot;</div><div class="line">var possibleInt = Int(myString)</div><div class="line">print(possibleInt)</div></pre></td></tr></table></figure></p>
<p>在上面这些代码中，possibleInt的值为7，因为myString包含这个整型的值。但是如果你把myString改成一个不能转换为整型的值的时候，possibleInt将会变成nil。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myString = &quot;banana&quot;</div><div class="line">possibleInt = Int(myString)</div><div class="line">print(possibleInt)</div></pre></td></tr></table></figure></p>
<p>数组是一种能跟踪有序集合中所有项的值的数据类型。使用中括号－－“［］”创建数组，通过在中括号中写入索引来访问数组中的元素。数组是从索引0开始的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ratingList = [&quot;Poor&quot;, &quot;Fine&quot;, &quot;Good&quot;, &quot;Excellent&quot;]</div><div class="line">ratingList[1] = &quot;OK&quot;</div><div class="line">ratingList</div></pre></td></tr></table></figure></p>
<p>如果要创建一个空的数组，可以使用初始化语法。稍后，你将会学习到更多关于初始化（译者注：也叫构造器）方面的知识。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Creates an empty array.</div><div class="line">let emptyArray = [String]()</div></pre></td></tr></table></figure></p>
<p>你可能注意到上面的代码有一段注释。注释是在源代码文件中的一段文本，其在编译的时候不会被编译器编译，但是它能提供上下文或者关于个人代码片段的有用的信息。单行注释写在双斜杠”//”之后，而多行注释写在一对由斜杠和星号组成的集合之间（/<em>……</em>/）。在本教程中，你将会看到并且会写到这两种不同类型的注释。</p>
<p>隐式解包可选类型同样可以作为非可选值，这样就不需要每次访问它们的时候都去对其进行解包。这是因为隐式可选类型在值被初始化之后，我们可以认为它总是有值的，虽然这个值可以变化。隐式解包可选类型使用感叹号（！）来解包，而不是问号（？）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var implicitlyUnwrappedOptionalInt: Int!</div></pre></td></tr></table></figure></p>
<p>在你的代码中，你真的会需要创建隐式解包可选类型。很多时候，你会在在本教程的视图和源代码（你会在接下来的课程中学习关于这方面的东西）之间追踪outlets（译者注：这是一个把视图跟代码连接起来的桥梁）的时候看到它们的存在，在相关的API中，你也会看到它们的存在。  </p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>Swift中有两种类型的控制流语句：第一个是条件语句，比如if和switch－－检查一个条件是否是真（true）－－也就是说，在执行一个代码段前，先计算它的值是否是布尔值true，；第二个是循环，比如for-in和while，多次执行相同的代码片段。  </p>
<p>If语句对某一个条件进行检查，如果条件是真（true），就执行在语句体内的代码。你可以通过在if语句中增加else子句定义更复杂的行为。else子句可以和if语句合成为链式使用，也可以自己单独使用－－在这种情况下，如果if的语句的结果不为真（true），那么就会执行else子句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let number = 23</div><div class="line">if number &lt; 10 &#123;</div><div class="line">    print(&quot;The number is small&quot;)</div><div class="line">&#125; else if number &gt; 100 &#123;</div><div class="line">    print(&quot;The number is pretty big&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;The number is between 10 and 100&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在if语句中使用可选绑定来检查可选类型是否有值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var optionalName: String? = &quot;John Appleseed&quot;</div><div class="line">var greeting = &quot;Hello!&quot;</div><div class="line">if let name = optionalName &#123;</div><div class="line">    greeting = &quot;Hello, \(name)&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>动手操作</strong><br> 将optionalName的值修改为nil，greeting会是什么值？增加一个else子句，在optionalName为nil的时候把greeting设置为不同的值。 </p>
</blockquote>
<p>如果可选值是nil，那么对应的条件就是false，相对应的括号中的代码就会被忽略。否则，可选值就被解包并赋给let之后的常量，使得被解包出来的值在代码块（if中）中能被使用。</p>
<p>你可以使用单个if语句绑定多个值。where子句可以添加到某一种情形中，以拓展条件语句。在这种情况下，if语句体只有在所有的值都成功绑定和条件都成立之后才被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var optionalHello: String? = &quot;Hello&quot;</div><div class="line">if let hello = optionalHello where hello.hasPrefix(&quot;H&quot;), let name = optionalName &#123;</div><div class="line">    greeting = &quot;\(hello), \(name)&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift在Switch中非常强大。一个switch语句支持各种类型的数据和大量的比对操作－－它并不局限于整型和简单地比较相等与否。在下面的例子中，switch语句对vegetable字符串的值在每一种case中进行比对，比对成功则这行相应的代码块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let vegetable = &quot;red pepper&quot;</div><div class="line">switch vegetable &#123;</div><div class="line">case &quot;celery&quot;:</div><div class="line">    let vegetableComment = &quot;Add some raisins and make ants on a log.&quot;</div><div class="line">case &quot;cucumber&quot;, &quot;watercress&quot;:</div><div class="line">    let vegetableComment = &quot;That would make a good tea sandwich.&quot;</div><div class="line">case let x where x.hasSuffix(&quot;pepper&quot;):</div><div class="line">    let vegetableComment = &quot;Is it a spicy \(x)?&quot;</div><div class="line">default:</div><div class="line">    let vegetableComment = &quot;Everything tastes good in soup.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>动手操作<br>尝试移除default项，你会发现什么错误？   </p>
</blockquote>
<p>注意let是如何在一个匹配的模式中被赋值为常量的。就比如在if语句中，where子句能添加到某一个条件中拓展条件语句。然而，区别于if语句，switch中，有多个通过逗号分隔的条件只要匹配上任何一个，相对应的代码块就会执行。</p>
<p>执行完switch匹配的代码块之后，程序将会从switch语句中退出。程序不会继续执行下一个条件项，所以你不需要在每个条件中显式地退出switch语句体（也就是不需要在每个条件中写break）。</p>
<p>Switch语句必须是详尽的。你需要在每个switch中写上default项，除非你已经明确地从上下文中满足了所有的条件－－比如当switch语句在遍历一个枚举的时候。这个要求确保了总会有一个switch条件被执行。</p>
<p>你可以通过使用范围（range）来获得索引。使用半开的范围操作符来创建一个索引的范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var firstForLoop = 0</div><div class="line">for i in 0..&lt;4 &#123;</div><div class="line">    firstForLoop += i</div><div class="line">&#125;</div><div class="line">print(firstForLoop)</div></pre></td></tr></table></figure></p>
<p>半开的范围操作符（..&lt;）不包括最大的数字，所以这个范围是从0到3，总共四次循环迭代。使用封闭的范围操作符（…）创建包括最大和最小数字的范围（range）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var secondForLoop = 0</div><div class="line">for _ in 0...4 &#123;</div><div class="line">    secondForLoop += 1</div><div class="line">&#125;</div><div class="line">print(secondForLoop)</div></pre></td></tr></table></figure></p>
<p>这个范围从0到4，总共执行五次循环。下划线（_）表示一个通配符，当你不需要知道循环中当前执行的迭代的时候，你可以使用它去忽略。</p>
<h3 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h3><p>函数是一种可以重复使用，在其中定义了一些代码的代码片段，在整个程序中，函数可以在很多地方被引用。使用func去声明一个函数。函数声明可以包含0个或者多个参数，格式如name:Type。这些参数是额外的信息，当你去调用方法的时候，你必须把这些额外的信息传递进去。另外，函数有可选的返回类型，格式如：-&gt;返回类型，这表明这个函数返回的结果。函数的视线写在大括号({})中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func greet(name: String, day: String) -&gt; String &#123;</div><div class="line">    return &quot;Hello \(name), today is \(day).&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过在函数名字后面加上一个参数（你传进函数中用以满足参数的值）列表来调用函数。当你调用函数的时候，你传进函数中的第一个参数不需要写出它的参数名字，其他的参数值都需要写出对应的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">greet(&quot;Anna&quot;, day: &quot;Tuesday&quot;)</div><div class="line">greet(&quot;Bob&quot;, day: &quot;Friday&quot;)</div><div class="line">greet(&quot;Charlie&quot;, day: &quot;a nice day&quot;)</div></pre></td></tr></table></figure></p>
<p>方法(method)是在一个特定的类型中定义的函数。方法（method）会隐式地关联到它所定义的类型上，且只有在这个所关联的类型（或者这个类型的子类，这个概念稍后你会接触到）上才可以调用这个方法。在之前的switch语句的例子中，你看到了定义在String类型上的hasSuffix()方法，这里再看一遍：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let exampleString = &quot;hello&quot;</div><div class="line">if exampleString.hasSuffix(&quot;lo&quot;) &#123;</div><div class="line">    print(&quot;ends in lo&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如你所看到的，调用方法是通过点语法(.)发起调用的。当你调用方法的时候，你传进方法中的第一个参数值不需要写出它对应的名字，而其它每一个参数都带有名字。比如，在数组（Array）中的这个方法需要两个参数，而你只需要为第二个参数加上名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var array = [&quot;apple&quot;, &quot;banana&quot;, &quot;dragonfruit&quot;]</div><div class="line">array.insert(&quot;cherry&quot;, atIndex: 2)</div><div class="line">array //译者注：这里的意思应该是打印print(array)</div></pre></td></tr></table></figure></p>
<h3 id="类和构造器"><a href="#类和构造器" class="headerlink" title="类和构造器"></a>类和构造器</h3><p>在面向对象编程中，程序的行为主要是基于对象之间的交互的。对象是类（class）的实例，实例可以认为你是对象的蓝图。类使用属性的方式存储关于它们自身的信息，使用方法定义它们的行为。  </p>
<p>通过在class关键字的后面加上类的名字来定义一个类。在类中，属性的写法和定义常量和变量相同，除了它是写在类的上下文中之外。同样地，方法的定义和函数的定义也是类似的。下面的例子声明了一个形状（Shape）类，其定义了一个名字为numberOfSides（边的数量）属性和一个simpleDescription()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Shape &#123;</div><div class="line">    var numberOfSides = 0</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;A shape with \(numberOfSides) sides.&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个类的实例，只需要在类的名字后面加上圆括号。使用点操作符（.）去访问实例中的属性和方法。下面的例子中，shape是Shape类的一个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var shape = Shape()</div><div class="line">shape.numberOfSides = 7</div><div class="line">var shapeDescription = shape.simpleDescription()</div></pre></td></tr></table></figure></p>
<p>这个Shape类缺少了一个重要的东西：构造器（initializer）。构造器是在类实例使用之前为实例做准备工作的一个方法，它包括为每一个属性设置一个初始值、执行任何其他的设置。使用init去声明一个构造器。下面的例子定义了一个新的类－－NamedShape，它是一个带有name参数的构造器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class NamedShape &#123;</div><div class="line">    var numberOfSides = 0</div><div class="line">    var name: String</div><div class="line">    </div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;A shape with \(numberOfSides) sides.&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意self是怎么用以区分name属性和构造器中的name参数的。每个属性都需要指定一个值，这个值要么在属性声明中（比如numberOfSides），要么在构造器中（比图name）。   </p>
<p>不要通过直接调用init去执行构造器；你应该通过在类名后面的圆括号中把合适的参数传递进去去调用。当你调用构造器的时候，你需要把所有的参数名字连同它的值传递进去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let namedShape = NamedShape(name: &quot;my named shape&quot;)</div></pre></td></tr></table></figure></p>
<p>类可以从它的父类中继承父类的行为。一个类继承了另外一个类的行为，则称这个类为子类（subclass），而被继承的类为父类（或者超类，superclass）。子类在自身的类名后面加上父类的名字，中间通过冒号分隔的形式实现继承。一个类只能继承一个父类，即时父类还可以继承另一个父类，等等，由此形成类层级（class hierarchy）。  </p>
<p>在子类中重写（override）父类的实现是通过override关键字标记的。为了防止意外重写了父类的实现，在没有override标记的时候，重写行为会被编译器当做error（错误）处理。编译器同样会检查在父类中没有存在却被标记为override的方法。 </p>
<p>下面的例子定义了Square类和一个名字为NamedShape的子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Square: NamedShape &#123;</div><div class="line">    var sideLength: Double</div><div class="line">    </div><div class="line">    init(sideLength: Double, name: String) &#123;</div><div class="line">        self.sideLength = sideLength</div><div class="line">        super.init(name: name)</div><div class="line">        numberOfSides = 4</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func area() -&gt;  Double &#123;</div><div class="line">        return sideLength * sideLength</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    override func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;A square with sides of length \(sideLength).&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let testSquare = Square(sideLength: 5.2, name: &quot;my test square&quot;)</div><div class="line">testSquare.area()</div><div class="line">testSquare.simpleDescription()</div></pre></td></tr></table></figure></p>
<p>需要注意Square类的构造器有三个不同的步骤： </p>
<ol>
<li>设置Square子类声明的属性值</li>
<li>调用父类NamedShape的构造函数</li>
<li>修改在父类NamedShape中定义的属性值。在这一步，任何额外的通过方法（method），获得方式（get）、设置方式（set）进行的设置工作都可以在这一步进行。</li>
</ol>
<p>有时候，当提供给参数的值不在预想的范围内，或者当需要的数据缺失的时候，对象的构造函数需要支持构造失败的情况。这种有可能导致对象初始化失败的构造器就做可失败构造器。可失败构造器在初始化的时候有可能会返回nil。使用init?声明一个可失败构造器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Circle: NamedShape &#123;</div><div class="line">    var radius: Double</div><div class="line">    </div><div class="line">    init?(radius: Double, name: String) &#123;</div><div class="line">        self.radius = radius</div><div class="line">        super.init(name: name)</div><div class="line">        numberOfSides = 1</div><div class="line">        if radius &lt;= 0 &#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    override func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;A circle with a radius of \(radius).&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let successfulCircle = Circle(radius: 4.2, name: &quot;successful circle&quot;)</div><div class="line">let failedCircle = Circle(radius: -7, name: &quot;failed circle&quot;)</div></pre></td></tr></table></figure></p>
<p>构造器还可以用一些关键词去修饰。指定构造器（designated initializer）不需要任何的关键词，这种构造器在类中是一种主要的构造器。在类中的任何构造器最终都必须调用一个指定构造器。  </p>
<p>和构造器紧邻的convenience关键词表明这事一个便利构造器。便利构造器是次要的构造器，通过其可以增加额外的行为或定制的服务。但是便利构造器最终必须调用一个指定构造器。  </p>
<p>和构造器紧邻的required关键词表明：在父类中持有必须要在子类实现的构造器时，子类就必须要通过override去实现构造器。  </p>
<p>类型转换是一种检查实例类型的方式，在这个类层次结构中，通过把这个实例当做是一个不同的子类或者父类来检查实例的类型。  </p>
<p>某一个类型的常量或者变量实际上对应一个看不见的子类的实例。当你确信这个类型是具体的类型时，你可以尝试用转换操作将其向下转换（downcast）成子类。  </p>
<p>由于向下转换有可能导致失败，所以类型转换操作会有两种不同的形式。第一种是可选的形式－－as?，这种形式将会返回一个可选的你尝试去转换的类型的值；第二种是强制的形式－－as!，这种形式会做一个复合的操作：尝试去向下转换并且对结果进行强制解包。  </p>
<p>当你不确定向下做类型转换能成功的时候，你可以使用可选类型绑定操作符（optional type cast operator）－－as?。这种形式的操作总会返回一个可选值，如果不能向下转换，这个值将会是nil。这可以让你检查向下类型转换是否成功。  </p>
<p>只有当你确定你的向下转换操作会成功的时候，你才可以使用强制类型转换操作符（forced type cast operator）－－as!。当你尝试转换了一个错误的类型时，这种形式的操作会触发一个运行时错误。  </p>
<p>下面的例子向你展示了可选类型转换操作（as?）的使用：这个例子检查了在shapes数组中的某一项shape是否是一个正方形（square）或者三角形（triangle）。每一次找出Shape时，会对相对应的变量squares和triangles加一，最后输出结果值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Triangle: NamedShape &#123;</div><div class="line">    init(sideLength: Double, name: String) &#123;</div><div class="line">        super.init(name: name)</div><div class="line">        numberOfSides = 3</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">let shapesArray = [Triangle(sideLength: 1.5, name: &quot;triangle1&quot;), Triangle(sideLength: 4.2, name: &quot;triangle2&quot;), Square(sideLength: 3.2, name: &quot;square1&quot;), Square(sideLength: 2.7, name: &quot;square2&quot;)]</div><div class="line">var squares = 0</div><div class="line">var triangles = 0</div><div class="line">for shape in shapesArray &#123;</div><div class="line">    if let square = shape as? Square &#123;</div><div class="line">        squares++</div><div class="line">    &#125; else if let triangle = shape as? Triangle &#123;</div><div class="line">        triangles++</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">print(&quot;\(squares) squares and \(triangles) triangles.&quot;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>动手操作</strong><br>尝试将 as?替换成as!。这时候你会捕获到什么错误？  </p>
</blockquote>
<h3 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h3><p>在Swift中，类不是定义数据类型的唯一的方式。枚举（enumerations）和结构体(structures)和类有相似的功能，但是它们在不同的上下文中却大有用处。 </p>
<p>枚举可以为一组相关的值定义一个公共的类型，它能让你在你的代码中使用一种类型安全的方式去处理这些值。枚举可以拥有与它们相关的方法。  </p>
<p>使用enum创建一个枚举。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">enum Rank: Int &#123;</div><div class="line">    case Ace = 1</div><div class="line">    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten</div><div class="line">    case Jack, Queen, King</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .Ace:</div><div class="line">            return &quot;ace&quot;</div><div class="line">        case .Jack:</div><div class="line">            return &quot;jack&quot;</div><div class="line">        case .Queen:</div><div class="line">            return &quot;queen&quot;</div><div class="line">        case .King:</div><div class="line">            return &quot;king&quot;</div><div class="line">        default:</div><div class="line">            return String(self.rawValue)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let ace = Rank.Ace</div><div class="line">let aceRawValue = ace.rawValue</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，枚举的原始值的类型是整型（Int），所以你只需要指定第一个原始值。剩余的原始值按照顺序赋值。你同样可以使用字符串或者浮点数作为枚举的原始值。使用rawValue属性可以访问到枚举成员的原始值。  </p>
<p>使用init?(rawValue:)构造函数创建一个从原始值开始的枚举的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if let convertedRank = Rank(rawValue: 3) &#123;</div><div class="line">    let threeDescription = convertedRank.simpleDescription()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>枚举的成员值是实际值，而不是通过另外一种方式写的原始值。事实上，在原始值没有实际意义的情况下，你不必提供原始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">enum Suit &#123;</div><div class="line">    case Spades, Hearts, Diamonds, Clubs</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .Spades:</div><div class="line">            return &quot;spades&quot;</div><div class="line">        case .Hearts:</div><div class="line">            return &quot;hearts&quot;</div><div class="line">        case .Diamonds:</div><div class="line">            return &quot;diamonds&quot;</div><div class="line">        case .Clubs:</div><div class="line">            return &quot;clubs&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let hearts = Suit.Hearts</div><div class="line">let heartsDescription = hearts.simpleDescription()</div></pre></td></tr></table></figure></p>
<p>注意上面的例子中，枚举中的成员Hearts中两种不同的表示方式：当hearts常量被赋值时，枚举成员Suit.Hearts是它的完整写法，因为常量没有隐式的类型指定。在switch中，枚举成员.Hearts是其简写的形式，因为self的值已经明确地确定为suit。任何时候，在你知道值的类型之后，你可以使用简写的形式。  </p>
<p>结构体和类一样支持很多相同的行为，包括方法和构造器。类和结构体之间最重要的一个区别是：结构体在代码中被传递时总是以复制的形式传递的，但是类是以引用传递的。结构体在定义轻量级的数据类型上是很完美的，它不需要有很多类似于继承和类型转换的功能。   </p>
<p>使用struct来创建一个结构体。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Card &#123;</div><div class="line">    var rank: Rank</div><div class="line">    var suit: Suit</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let threeOfSpades = Card(rank: .Three, suit: .Spades)</div><div class="line">let threeOfSpadesDescription = threeOfSpades.simpleDescription()</div></pre></td></tr></table></figure>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议是定义了一系列方法、属性和其它特定任务或功能的蓝图。协议事实上不提供任何这些需求的实现，它只是描述了实现的轮廓。协议定义之后可以被一个类、结构体或枚举采用以提供那些需求的具体实现。任何满足了协议的需求的行为，我们称之为遵循（conform）了那个协议。   </p>
<p>使用protocol定义一个协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol ExampleProtocol &#123;</div><div class="line">    var simpleDescription: String &#123; get &#125;</div><div class="line">    func adjust()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意<br>在simpleDescription属性之后的{ get }表示这是一个只读的属性，意味着这个属性的值只能获取，不能改变。</p>
</blockquote>
<p>协议可以要求遵循它的类型持有指定的实例属性，实例方法，操作符和下标脚本。协议要求遵循它的类型必须实现其中的实例方法和类型方法。这些方法和普通的实例和类型方法一样，定义在协议中，但是没有圆括号或方法体。  </p>
<p>类、结构体和枚举通过在其名字后面写上一个冒号，冒号后列出协议的名字的写法来实现遵循协议。一个类型可以遵循任何数量的协议，协议中间通过逗号分隔。如果类有父类，那么父类必须出现在列表的最前面，后面才跟着协议。你需要通过实现所有的协议的需求来实现协议的遵循。  </p>
<p>下面的例子中，SimpleClass采用了ExampleProtocol协议，通过实现simpleDescription属性和adjust()方法以实现遵循该协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class SimpleClass: ExampleProtocol &#123;</div><div class="line">    var simpleDescription: String = &quot;A very simple class.&quot;</div><div class="line">    var anotherProperty: Int = 69105</div><div class="line">    func adjust() &#123;</div><div class="line">        simpleDescription += &quot;  Now 100% adjusted.&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var a = SimpleClass()</div><div class="line">a.adjust()</div><div class="line">let aDescription = a.simpleDescription</div></pre></td></tr></table></figure></p>
<p>协议是高级类型，这意味着它们可以当做其它命名过的类型使用。比如，你可以创建一个ExampleProtocol数组，然后在数组的每一个实例中调用adjust()方法（因为在数组中的任何实例会保证实现了adjust()方法－－这是协议的要求）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class SimpleClass2: ExampleProtocol &#123;</div><div class="line">    var simpleDescription: String = &quot;Another very simple class.&quot;</div><div class="line">    func adjust() &#123;</div><div class="line">        simpleDescription += &quot;  Adjusted.&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">var protocolArray: [ExampleProtocol] = [SimpleClass(), SimpleClass(), SimpleClass2()]</div><div class="line">for instance in protocolArray &#123;</div><div class="line">    instance.adjust()</div><div class="line">&#125;</div><div class="line">protocolArray</div></pre></td></tr></table></figure></p>
<h3 id="Swift和Cocoa-Touch框架"><a href="#Swift和Cocoa-Touch框架" class="headerlink" title="Swift和Cocoa Touch框架"></a>Swift和Cocoa Touch框架</h3><p>Cocoa Touch是用来开发苹果iOS应用的一个框架的集合，Swift是按照与Cocoa Touch框架无缝衔接来设计的。在你往后的课程的学习中，你会对Swift如何与Cocoa Touch框架进行交互有一个基本的理解。  </p>
<p>至此，你已经学习了Swift标准库中所有的数据类型。Swift标准库(Swift standard library)是为Swift设计的一个数据类型和功能的集合，并将这些融合成为一门语言。在标准库中，像String和Array这样的类型就是数据类型的一些例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let sampleString: String = &quot;hello&quot;</div><div class="line">let sampleArray: Array = [1, 2, 3.1415, 23, 42]</div></pre></td></tr></table></figure></p>
<blockquote>
<p>动手操作<br>通过Option-click在Xcode中的数据类型，查阅Swift标准库中的类型的具体实现。在上面的playground代码中，在String和Array上面Option-click，查看相应的结果。  </p>
</blockquote>
<p>当你在开发iOS应用的时候，你不会仅仅使用到Swift标准库。在iOS应用开发中，另一个你会频繁用到的框架是UIKit。UIKit包含了针对应用的UI层级（用户界面，usere interface）设计的有用的类。  </p>
<p>要使用UIKit，只需要在Swift文件或playground文件中简单地把它当做模块导入即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import UIKit</div></pre></td></tr></table></figure></p>
<p>导入了UIKit之后，你可以使用Swift语法来使用UIKit中的类型以及它们相关的方法、属性等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let redSquare = UIView(frame: CGRect(x: 0, y: 0, width: 44, height: 44))</div><div class="line">redSquare.backgroundColor = UIColor.redColor()</div></pre></td></tr></table></figure></p>
<p>在教程中很多介绍到的类都是来自于UIKit中的，所以你会经常看到这个导入UIKit的语句。  </p>
<p>在经过大量的Swift知识的介绍之后，相信你已经准备好在下一门课程中创建一个功能完整的应用了。虽然这一章节结束之后，你将不会再需要使用到playground了，但是请记住在应用开发中playground是一个很强大的工具，它能帮助你调试，查看上下文代码，提高原型设计效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你的第一门课程将会以playground的形式呈现。如第一章所说，playground是一种文件类型，它能让你在其中修改你的Swift代码，并能立即看到代码的运行结果。Playgrounds对于Swift学习和尝试是很棒的一个功能，它能帮助你加速对Swift基础概念的了解。
    
    </summary>
    
      <category term="Swift" scheme="http://www.ruanjiawei.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://www.ruanjiawei.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>苹果官方iOS入门教程译版之第一章：Jump Right In</title>
    <link href="http://www.ruanjiawei.com/2016/07/19/Start-Developing-iOS-Apps-Swift-1/"/>
    <id>http://www.ruanjiawei.com/2016/07/19/Start-Developing-iOS-Apps-Swift-1/</id>
    <published>2016-07-18T16:01:21.000Z</published>
    <updated>2016-08-08T07:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个教程（入门教程－使用swift开发iOS应用）对于构建运行于iPhone和iPad的应用来说是一个很好的入门教程。把这些课程当作一个指导性的入门教程来看，用它来创建你的第一个app－这个app包括工具（tools）、主要的概念和最好的体验，这些将会帮助你少走弯路。  </p>
<p>每个章节都含有详细的教程，通过这些指导你需要去掌握这些概念性的信息。针对你们所有人创建的这些课程，将会帮助你们一步一步地创建一个简单而真实的iOS应用。 </p>
<p>在你通过这些教程创建应用的过程中，你将会学习到关于iOS应用开发的概念，得到Swift更深层次的理解，熟悉苹果集成软件开发工具（Xcode）的很多特性。</p>
<h3 id="课程信息"><a href="#课程信息" class="headerlink" title="课程信息"></a>课程信息</h3><p>在这些课程中，你将会构建一个简单的“美食追踪”应用，我们管它叫“FoodTracker”。这个应用将会展示一个美食列表，包括美食名称、排名和图片。用户可以增加美食项，移除或者编辑一项已经存在的美食。为了能够增加一份美食，或者编辑一个已经存在的美食项，用户需要跳转到一个不同的界面－－在这个界面，用户可以为美食项指定美食名称，排名和图片。（效果如下图）  </p>
<p><img src="https://calvin92.gitbooks.io/apple-ios-swift-start/content/jumprightin_1.png" alt="app_profile_image">   </p>
<p>你的第一课是一个playground。playground是Xcode文件的一种类型，它能让你跟你的代码交互，并能看到即时的输出结果。你将会下载这个playground文件，在Xcode中打开，使用它来熟悉Swift中的主要的概念。 </p>
<p>剩余的课程是带你实现项目，教程的最后，你将会看到你项目最终的代码和界面的样子。在你学完一个课程之后，你可以下载这个工程，通过其检查你的成果。  </p>
<p>如果你需要参考在整个教程中你已经学习过的概念，使用“词汇表（glossary）”来更新你的记忆。“词汇表”词条在整个课程中都有链接。 </p>
<h3 id="获取工具"><a href="#获取工具" class="headerlink" title="获取工具"></a>获取工具</h3><p>为了能够使用在本教程中描述的最新的技术来开发iOS应用，你需要一台Mac电脑（OSX 10.10或更新的系统）来运行最新版本的Xcode。Xcode涵盖了你需要用来设计、开发和调试的所有特性，它还包含Xcode的拓展iOS SDK，这里面包括你用来特地开发iOS的工具，编译器，和框架。 </p>
<p>通过App Store，在你的Mac上免费下载最新版本的Xcode。</p>
<p><strong>下载最新版本的Xcode（步骤）：</strong></p>
<ol>
<li>打开你的Mac上的App Store应用（默认情况下它在你的Dock中）</li>
<li>在右上角的搜索框中，输入Xcode，然后按回车键。（Xcode应用将会在搜索结果的第一项展现出来）</li>
<li>点击“Get”，然后点击“Install App”</li>
<li>在弹出的确认框中输入你的Apple ID和密码，确认后Xcode将会下载在你的“/Application”目录中   </li>
</ol>
<blockquote>
<p><strong>重要提示 </strong><br>   这个教程使用的是Xcode7.0和iOS SDK9.0。在你通过这个指南进行学习之前，请确保你使用的是这些版本的Xcode和iOS SDK。</p>
</blockquote>
<p>让我们开始吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个教程（入门教程－使用swift开发iOS应用）对于构建运行于iPhone和iPad的应用来说是一个很好的入门教程。把这些课程当作一个指导性的入门教程来看，用它来创建你的第一个app－这个app包括工具（tools）、主要的概念和最好的体验，这些将会帮助你少走弯路。  &lt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.ruanjiawei.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://www.ruanjiawei.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>迷糊的周末</title>
    <link href="http://www.ruanjiawei.com/2016/07/02/my-first-blog/"/>
    <id>http://www.ruanjiawei.com/2016/07/02/my-first-blog/</id>
    <published>2016-07-02T12:50:45.000Z</published>
    <updated>2016-08-08T08:37:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://music.163.com/#/song?id=94682" target="_blank" rel="external">如何掉眼泪</a> </p>
<p>难得有时间刷了一遍空间，恍然间发觉，又是毕业季了。</p>
<p>隔着屏幕都能感受到的毕业季的忧桑，又撩起了一阵阵的回忆。彼时匆忙，从北京回到渣科的时候，已经是武汉闷骚的六月了。匆忙整理完毕业手续的时候，已经到了六月中旬。从东三楼的毕设老师办公室交完最后一份材料出来的时候，路过机械楼，在楼梯上坐了半个下午。</p>
<p>机械大楼对面是材料学院的大楼，然后作为自家学院的大楼，却没有几次机会进出。两栋大楼之间的校园林荫道上，穿梭着或嬉笑、或抑郁的人流，恍惚间发觉，自己离这些人，竟是那么遥远了。 </p>
<p>从机械楼走回韵苑的路上，路过绝望坡的时候，正是放学时间，熙熙攘攘的人群开始聚集在这个在我看来并没有那么绝望的坡上－－兴许是陪伴了我两年多后被姚思橙弄丢的小电驴带给我的错觉吧。</p>
<p>绝望坡两侧分布着各种各样的小店铺，放学时间这里人满为患的总是那些小食堂。转头走进了同窗堂，点了一份木耳炒肉盖饭，随即坐在一个靠窗的角落里，打量着这个我第一次光顾的小店。想起大一刚进来的时候，跟浩然下定决心，要把渣科30多个食堂吃个遍。然而，这几年，几乎永远都是在韵苑大酒店和东园之间徘徊。 </p>
<p>那天吃完饭，也不晓得是怎么回到寝室的，打开门的时候，看到室友已经把部分东西整理好，打包到角落里了。室友不在，心有些累，爬上床，迷迷糊糊地睡过去了。醒来的时候，已经是夜里10点多，正是寝室最热闹的时候，主席他们过来串门，也不晓得聊了什么，大家都有些伤感。也不知道什么时候大家熄灯上床了，隐隐约约听到浩然床上传来抽泣的声音，在这一刻有些被感染，原来我们距离离别，是那么地近了。 </p>
<p>距离学校要求离校的deadline还剩两天的时候，大家都已经把东西收拾得差不多，随时准备离校了。那天晚上，那顿聚餐吃得很晚，由CEO带头的哭声感染了在场的所有人，于是大家三三两两地抱在一起痛哭。</p>
<p>大约到了凌晨，所有人拖着不省人事的浩然往学校走回去。在韵苑足球场，大家围着躺尸的浩然又继续嘻哈了一把。旁边有很多跟我们一样的毕业生，在被泪水冲击过后都大吼大叫地释放自己的情绪，大雕哥还追着操场上的妹子去求抱抱，整个场面夹杂着欢乐的同时，却尽是无尽的伤感－－Anyway，it is the last moment we all enjoy。 </p>
<p>离别不是终点，但什么时候，我们能在下一个起点重逢？ 不幸的HUST DF1102，我们已经失去了一个可爱的同窗，期待下次的见面，各自安好。<br><img src="../../../../images/graduation.JPG" alt="最后一天，送我离汉的你们"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;难得有时间刷了一遍空间，恍然间发觉，又是毕业季了。&lt;/p&gt;&lt;p&gt;隔着屏幕都能感受到的毕业季的忧桑，又撩起了一阵阵的回忆。彼时匆忙，从北京回到渣科的时候，已经是武汉闷骚的六月了。匆忙整理完毕业手续的时候，已经到了六月中旬。从东三楼的毕设老师办公室交完最后一份材料出来的时候，路过机械楼，在楼梯上坐了半个下午。&lt;/p&gt;
    
    </summary>
    
      <category term="躁动的心" scheme="http://www.ruanjiawei.com/categories/%E8%BA%81%E5%8A%A8%E7%9A%84%E5%BF%83/"/>
    
    
      <category term="死宅" scheme="http://www.ruanjiawei.com/tags/%E6%AD%BB%E5%AE%85/"/>
    
  </entry>
  
</feed>
