<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="I'am Calvin,a crazy JSer"><title>苹果官方iOS入门教程译版之第二章：Learn the Essentials of Swift | 开车上纽北</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">苹果官方iOS入门教程译版之第二章：Learn the Essentials of Swift</h1><a id="logo" href="/.">开车上纽北</a><p class="description">一个在灯红酒绿的大城市五环外飙车的老司机</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">苹果官方iOS入门教程译版之第二章：Learn the Essentials of Swift</h1><div class="post-meta">Aug 8, 2016<span> | </span><span class="category"><a href="/categories/Swift/">Swift</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/08/08/Start-Developing-iOS-Apps-Swift-2/" href="/2016/08/08/Start-Developing-iOS-Apps-Swift-2/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#学习目标"><span class="toc-number">1.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型"><span class="toc-number">2.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制流"><span class="toc-number">3.</span> <span class="toc-text">控制流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数和方法"><span class="toc-number">4.</span> <span class="toc-text">函数和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类和构造器"><span class="toc-number">5.</span> <span class="toc-text">类和构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举和结构体"><span class="toc-number">6.</span> <span class="toc-text">枚举和结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协议"><span class="toc-number">7.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift和Cocoa-Touch框架"><span class="toc-number">8.</span> <span class="toc-text">Swift和Cocoa Touch框架</span></a></li></ol></div></div><div class="post-content"><p>你的第一门课程将会以playground的形式呈现。如第一章所说，playground是一种文件类型，它能让你在其中修改你的Swift代码，并能立即看到代码的运行结果。Playgrounds对于Swift学习和尝试是很棒的一个功能，它能帮助你加速对Swift基础概念的了解。 </p>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>在本章的最后，你将掌握以下这些：</p>
<ul>
<li>区分常量和变量</li>
<li>了解何时使用隐式和显示的类型声明</li>
<li>理解使用可选类型和可选类型绑定的优势</li>
<li>区分可选类型(optionals)和隐式解包的可选类型(implicitly unwrapped optionals)</li>
<li>理解条件语句和循环的目的</li>
<li>超过双重判断条件时使用switch语句来做条件判断</li>
<li>在条件语句中使用where来增加条件约束</li>
<li>区分函数、方法和构造器</li>
<li>区分类，结构体和枚举</li>
<li>理解继承和协议一致性(protocol conformance)的语法</li>
<li>确定隐式的类型，使用Xcode的快速帮助（quick help）快捷方式（Option-Click）查看更多的信息</li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>常量在一开始被声明之后就一直保持同样的值，而变量在声明之后可以被改变。常量意味着它是不可变的，而变量是可变的。如果你一开始就知道你的值在你的代码中就不会改变，那你应该声明它为常量而不是变量。<br>使用let创建一个常量，var创建一个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myVariable = 42</div><div class="line">myVariable = 50</div><div class="line">let myConstant = 42</div></pre></td></tr></table></figure></p>
<p>每个常量和变量在Swift中都有一个类型，但是你不必显式地把类型写出来。当你声明一个常量或者变量的时候，提供给这个常量或者变量一个值，让编译器去推断它的类型。在上面的例子中，编译器推断出myVariable是一个整型，因为它的初始值是一个整型值。这种特性叫做类型推断。一旦常量或者变量有了一个类型，那么这个类型就不能改变。</p>
<p>如果初始值提供不了足够的信息（或者没有初始值），那你需要通过在变量名之后为其指定类型，中间通过冒号分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let implicitInteger = 70</div><div class="line">let implicitDouble = 70.0</div><div class="line">let explicitDouble: Double = 70</div></pre></td></tr></table></figure></p>
<blockquote>
<p>动手操作<br>在Xcode中，试试Option-Click(译者注：按住option键再点击，本教程中所有的这种写法的操作都类似)常量或者变量的名字，查看它的推断类型。使用上面代码中的常量去动手尝试。</p>
</blockquote>
<p>值永远不会隐式地转换为另一种类型。如果你需要把一个值转换为另一种不同的类型，那你需要显式地创建一个你期望的类型的实例。在下面的例子中，你将转换一个Int类型的值为一个String类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let label = &quot;The width is &quot;</div><div class="line">let width = 94</div><div class="line">let widthLabel = label + String(width)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>动手操作<br>尝试把上面代码最后一行的String去掉。你会发现什么错误？</p>
</blockquote>
<p>还有一种更简单的方式把值转换成String类型：在圆括号中写值，并在圆括号中的开始处插入反斜杠“\”。这就是我们熟悉的字符串插值表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let apples = 3</div><div class="line">let oranges = 5</div><div class="line">let appleSummary = &quot;I have \(apples) apples.&quot;</div><div class="line">let fruitSummary = &quot;I have \(apples + oranges) pieces of fruit.&quot;</div></pre></td></tr></table></figure></p>
<p>使用可选类型处理值有可能出现值缺失的情况。可选类型的值要么包含一个值，要么就是一个表明值缺失的nil（没有值）。在值的类型后面加上问号（？）以标记该值为可选类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let optionalInt: Int? = 9</div></pre></td></tr></table></figure></p>
<p>为了从一个可选类型中得到隐含的值，你需要对它进行解包。你稍后将会学习解包可选类型，但是你可以采用最直接的方式－－用强制解包操作符号（！）来进行解包。只有在你确定隐含的值不为nil的时候，你才能用强制解包操作符来进行解包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let actualInt: Int = optionalInt!</div></pre></td></tr></table></figure></p>
<p>可选类型在Swift中是普遍的。在很多情况下，当一个值也许需要又也许不需要呈现的时候，可选类型是非常有用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myString = &quot;7&quot;</div><div class="line">var possibleInt = Int(myString)</div><div class="line">print(possibleInt)</div></pre></td></tr></table></figure></p>
<p>在上面这些代码中，possibleInt的值为7，因为myString包含这个整型的值。但是如果你把myString改成一个不能转换为整型的值的时候，possibleInt将会变成nil。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myString = &quot;banana&quot;</div><div class="line">possibleInt = Int(myString)</div><div class="line">print(possibleInt)</div></pre></td></tr></table></figure></p>
<p>数组是一种能跟踪有序集合中所有项的值的数据类型。使用中括号－－“［］”创建数组，通过在中括号中写入索引来访问数组中的元素。数组是从索引0开始的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ratingList = [&quot;Poor&quot;, &quot;Fine&quot;, &quot;Good&quot;, &quot;Excellent&quot;]</div><div class="line">ratingList[1] = &quot;OK&quot;</div><div class="line">ratingList</div></pre></td></tr></table></figure></p>
<p>如果要创建一个空的数组，可以使用初始化语法。稍后，你将会学习到更多关于初始化（译者注：也叫构造器）方面的知识。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Creates an empty array.</div><div class="line">let emptyArray = [String]()</div></pre></td></tr></table></figure></p>
<p>你可能注意到上面的代码有一段注释。注释是在源代码文件中的一段文本，其在编译的时候不会被编译器编译，但是它能提供上下文或者关于个人代码片段的有用的信息。单行注释写在双斜杠”//”之后，而多行注释写在一对由斜杠和星号组成的集合之间（/<em>……</em>/）。在本教程中，你将会看到并且会写到这两种不同类型的注释。</p>
<p>隐式解包可选类型同样可以作为非可选值，这样就不需要每次访问它们的时候都去对其进行解包。这是因为隐式可选类型在值被初始化之后，我们可以认为它总是有值的，虽然这个值可以变化。隐式解包可选类型使用感叹号（！）来解包，而不是问号（？）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var implicitlyUnwrappedOptionalInt: Int!</div></pre></td></tr></table></figure></p>
<p>在你的代码中，你真的会需要创建隐式解包可选类型。很多时候，你会在在本教程的视图和源代码（你会在接下来的课程中学习关于这方面的东西）之间追踪outlets（译者注：这是一个把视图跟代码连接起来的桥梁）的时候看到它们的存在，在相关的API中，你也会看到它们的存在。  </p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>Swift中有两种类型的控制流语句：第一个是条件语句，比如if和switch－－检查一个条件是否是真（true）－－也就是说，在执行一个代码段前，先计算它的值是否是布尔值true，；第二个是循环，比如for-in和while，多次执行相同的代码片段。  </p>
<p>If语句对某一个条件进行检查，如果条件是真（true），就执行在语句体内的代码。你可以通过在if语句中增加else子句定义更复杂的行为。else子句可以和if语句合成为链式使用，也可以自己单独使用－－在这种情况下，如果if的语句的结果不为真（true），那么就会执行else子句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let number = 23</div><div class="line">if number &lt; 10 &#123;</div><div class="line">    print(&quot;The number is small&quot;)</div><div class="line">&#125; else if number &gt; 100 &#123;</div><div class="line">    print(&quot;The number is pretty big&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;The number is between 10 and 100&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在if语句中使用可选绑定来检查可选类型是否有值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var optionalName: String? = &quot;John Appleseed&quot;</div><div class="line">var greeting = &quot;Hello!&quot;</div><div class="line">if let name = optionalName &#123;</div><div class="line">    greeting = &quot;Hello, \(name)&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>动手操作</strong><br> 将optionalName的值修改为nil，greeting会是什么值？增加一个else子句，在optionalName为nil的时候把greeting设置为不同的值。 </p>
</blockquote>
<p>如果可选值是nil，那么对应的条件就是false，相对应的括号中的代码就会被忽略。否则，可选值就被解包并赋给let之后的常量，使得被解包出来的值在代码块（if中）中能被使用。</p>
<p>你可以使用单个if语句绑定多个值。where子句可以添加到某一种情形中，以拓展条件语句。在这种情况下，if语句体只有在所有的值都成功绑定和条件都成立之后才被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var optionalHello: String? = &quot;Hello&quot;</div><div class="line">if let hello = optionalHello where hello.hasPrefix(&quot;H&quot;), let name = optionalName &#123;</div><div class="line">    greeting = &quot;\(hello), \(name)&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift在Switch中非常强大。一个switch语句支持各种类型的数据和大量的比对操作－－它并不局限于整型和简单地比较相等与否。在下面的例子中，switch语句对vegetable字符串的值在每一种case中进行比对，比对成功则这行相应的代码块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let vegetable = &quot;red pepper&quot;</div><div class="line">switch vegetable &#123;</div><div class="line">case &quot;celery&quot;:</div><div class="line">    let vegetableComment = &quot;Add some raisins and make ants on a log.&quot;</div><div class="line">case &quot;cucumber&quot;, &quot;watercress&quot;:</div><div class="line">    let vegetableComment = &quot;That would make a good tea sandwich.&quot;</div><div class="line">case let x where x.hasSuffix(&quot;pepper&quot;):</div><div class="line">    let vegetableComment = &quot;Is it a spicy \(x)?&quot;</div><div class="line">default:</div><div class="line">    let vegetableComment = &quot;Everything tastes good in soup.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>动手操作<br>尝试移除default项，你会发现什么错误？   </p>
</blockquote>
<p>注意let是如何在一个匹配的模式中被赋值为常量的。就比如在if语句中，where子句能添加到某一个条件中拓展条件语句。然而，区别于if语句，switch中，有多个通过逗号分隔的条件只要匹配上任何一个，相对应的代码块就会执行。</p>
<p>执行完switch匹配的代码块之后，程序将会从switch语句中退出。程序不会继续执行下一个条件项，所以你不需要在每个条件中显式地退出switch语句体（也就是不需要在每个条件中写break）。</p>
<p>Switch语句必须是详尽的。你需要在每个switch中写上default项，除非你已经明确地从上下文中满足了所有的条件－－比如当switch语句在遍历一个枚举的时候。这个要求确保了总会有一个switch条件被执行。</p>
<p>你可以通过使用范围（range）来获得索引。使用半开的范围操作符来创建一个索引的范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var firstForLoop = 0</div><div class="line">for i in 0..&lt;4 &#123;</div><div class="line">    firstForLoop += i</div><div class="line">&#125;</div><div class="line">print(firstForLoop)</div></pre></td></tr></table></figure></p>
<p>半开的范围操作符（..&lt;）不包括最大的数字，所以这个范围是从0到3，总共四次循环迭代。使用封闭的范围操作符（…）创建包括最大和最小数字的范围（range）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var secondForLoop = 0</div><div class="line">for _ in 0...4 &#123;</div><div class="line">    secondForLoop += 1</div><div class="line">&#125;</div><div class="line">print(secondForLoop)</div></pre></td></tr></table></figure></p>
<p>这个范围从0到4，总共执行五次循环。下划线（_）表示一个通配符，当你不需要知道循环中当前执行的迭代的时候，你可以使用它去忽略。</p>
<h3 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h3><p>函数是一种可以重复使用，在其中定义了一些代码的代码片段，在整个程序中，函数可以在很多地方被引用。使用func去声明一个函数。函数声明可以包含0个或者多个参数，格式如name:Type。这些参数是额外的信息，当你去调用方法的时候，你必须把这些额外的信息传递进去。另外，函数有可选的返回类型，格式如：-&gt;返回类型，这表明这个函数返回的结果。函数的视线写在大括号({})中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func greet(name: String, day: String) -&gt; String &#123;</div><div class="line">    return &quot;Hello \(name), today is \(day).&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过在函数名字后面加上一个参数（你传进函数中用以满足参数的值）列表来调用函数。当你调用函数的时候，你传进函数中的第一个参数不需要写出它的参数名字，其他的参数值都需要写出对应的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">greet(&quot;Anna&quot;, day: &quot;Tuesday&quot;)</div><div class="line">greet(&quot;Bob&quot;, day: &quot;Friday&quot;)</div><div class="line">greet(&quot;Charlie&quot;, day: &quot;a nice day&quot;)</div></pre></td></tr></table></figure></p>
<p>方法(method)是在一个特定的类型中定义的函数。方法（method）会隐式地关联到它所定义的类型上，且只有在这个所关联的类型（或者这个类型的子类，这个概念稍后你会接触到）上才可以调用这个方法。在之前的switch语句的例子中，你看到了定义在String类型上的hasSuffix()方法，这里再看一遍：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let exampleString = &quot;hello&quot;</div><div class="line">if exampleString.hasSuffix(&quot;lo&quot;) &#123;</div><div class="line">    print(&quot;ends in lo&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如你所看到的，调用方法是通过点语法(.)发起调用的。当你调用方法的时候，你传进方法中的第一个参数值不需要写出它对应的名字，而其它每一个参数都带有名字。比如，在数组（Array）中的这个方法需要两个参数，而你只需要为第二个参数加上名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var array = [&quot;apple&quot;, &quot;banana&quot;, &quot;dragonfruit&quot;]</div><div class="line">array.insert(&quot;cherry&quot;, atIndex: 2)</div><div class="line">array //译者注：这里的意思应该是打印print(array)</div></pre></td></tr></table></figure></p>
<h3 id="类和构造器"><a href="#类和构造器" class="headerlink" title="类和构造器"></a>类和构造器</h3><p>在面向对象编程中，程序的行为主要是基于对象之间的交互的。对象是类（class）的实例，实例可以认为你是对象的蓝图。类使用属性的方式存储关于它们自身的信息，使用方法定义它们的行为。  </p>
<p>通过在class关键字的后面加上类的名字来定义一个类。在类中，属性的写法和定义常量和变量相同，除了它是写在类的上下文中之外。同样地，方法的定义和函数的定义也是类似的。下面的例子声明了一个形状（Shape）类，其定义了一个名字为numberOfSides（边的数量）属性和一个simpleDescription()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Shape &#123;</div><div class="line">    var numberOfSides = 0</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;A shape with \(numberOfSides) sides.&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个类的实例，只需要在类的名字后面加上圆括号。使用点操作符（.）去访问实例中的属性和方法。下面的例子中，shape是Shape类的一个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var shape = Shape()</div><div class="line">shape.numberOfSides = 7</div><div class="line">var shapeDescription = shape.simpleDescription()</div></pre></td></tr></table></figure></p>
<p>这个Shape类缺少了一个重要的东西：构造器（initializer）。构造器是在类实例使用之前为实例做准备工作的一个方法，它包括为每一个属性设置一个初始值、执行任何其他的设置。使用init去声明一个构造器。下面的例子定义了一个新的类－－NamedShape，它是一个带有name参数的构造器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class NamedShape &#123;</div><div class="line">    var numberOfSides = 0</div><div class="line">    var name: String</div><div class="line">    </div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;A shape with \(numberOfSides) sides.&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意self是怎么用以区分name属性和构造器中的name参数的。每个属性都需要指定一个值，这个值要么在属性声明中（比如numberOfSides），要么在构造器中（比图name）。   </p>
<p>不要通过直接调用init去执行构造器；你应该通过在类名后面的圆括号中把合适的参数传递进去去调用。当你调用构造器的时候，你需要把所有的参数名字连同它的值传递进去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let namedShape = NamedShape(name: &quot;my named shape&quot;)</div></pre></td></tr></table></figure></p>
<p>类可以从它的父类中继承父类的行为。一个类继承了另外一个类的行为，则称这个类为子类（subclass），而被继承的类为父类（或者超类，superclass）。子类在自身的类名后面加上父类的名字，中间通过冒号分隔的形式实现继承。一个类只能继承一个父类，即时父类还可以继承另一个父类，等等，由此形成类层级（class hierarchy）。  </p>
<p>在子类中重写（override）父类的实现是通过override关键字标记的。为了防止意外重写了父类的实现，在没有override标记的时候，重写行为会被编译器当做error（错误）处理。编译器同样会检查在父类中没有存在却被标记为override的方法。 </p>
<p>下面的例子定义了Square类和一个名字为NamedShape的子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Square: NamedShape &#123;</div><div class="line">    var sideLength: Double</div><div class="line">    </div><div class="line">    init(sideLength: Double, name: String) &#123;</div><div class="line">        self.sideLength = sideLength</div><div class="line">        super.init(name: name)</div><div class="line">        numberOfSides = 4</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func area() -&gt;  Double &#123;</div><div class="line">        return sideLength * sideLength</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    override func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;A square with sides of length \(sideLength).&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let testSquare = Square(sideLength: 5.2, name: &quot;my test square&quot;)</div><div class="line">testSquare.area()</div><div class="line">testSquare.simpleDescription()</div></pre></td></tr></table></figure></p>
<p>需要注意Square类的构造器有三个不同的步骤： </p>
<ol>
<li>设置Square子类声明的属性值</li>
<li>调用父类NamedShape的构造函数</li>
<li>修改在父类NamedShape中定义的属性值。在这一步，任何额外的通过方法（method），获得方式（get）、设置方式（set）进行的设置工作都可以在这一步进行。</li>
</ol>
<p>有时候，当提供给参数的值不在预想的范围内，或者当需要的数据缺失的时候，对象的构造函数需要支持构造失败的情况。这种有可能导致对象初始化失败的构造器就做可失败构造器。可失败构造器在初始化的时候有可能会返回nil。使用init?声明一个可失败构造器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Circle: NamedShape &#123;</div><div class="line">    var radius: Double</div><div class="line">    </div><div class="line">    init?(radius: Double, name: String) &#123;</div><div class="line">        self.radius = radius</div><div class="line">        super.init(name: name)</div><div class="line">        numberOfSides = 1</div><div class="line">        if radius &lt;= 0 &#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    override func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;A circle with a radius of \(radius).&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let successfulCircle = Circle(radius: 4.2, name: &quot;successful circle&quot;)</div><div class="line">let failedCircle = Circle(radius: -7, name: &quot;failed circle&quot;)</div></pre></td></tr></table></figure></p>
<p>构造器还可以用一些关键词去修饰。指定构造器（designated initializer）不需要任何的关键词，这种构造器在类中是一种主要的构造器。在类中的任何构造器最终都必须调用一个指定构造器。  </p>
<p>和构造器紧邻的convenience关键词表明这事一个便利构造器。便利构造器是次要的构造器，通过其可以增加额外的行为或定制的服务。但是便利构造器最终必须调用一个指定构造器。  </p>
<p>和构造器紧邻的required关键词表明：在父类中持有必须要在子类实现的构造器时，子类就必须要通过override去实现构造器。  </p>
<p>类型转换是一种检查实例类型的方式，在这个类层次结构中，通过把这个实例当做是一个不同的子类或者父类来检查实例的类型。  </p>
<p>某一个类型的常量或者变量实际上对应一个看不见的子类的实例。当你确信这个类型是具体的类型时，你可以尝试用转换操作将其向下转换（downcast）成子类。  </p>
<p>由于向下转换有可能导致失败，所以类型转换操作会有两种不同的形式。第一种是可选的形式－－as?，这种形式将会返回一个可选的你尝试去转换的类型的值；第二种是强制的形式－－as!，这种形式会做一个复合的操作：尝试去向下转换并且对结果进行强制解包。  </p>
<p>当你不确定向下做类型转换能成功的时候，你可以使用可选类型绑定操作符（optional type cast operator）－－as?。这种形式的操作总会返回一个可选值，如果不能向下转换，这个值将会是nil。这可以让你检查向下类型转换是否成功。  </p>
<p>只有当你确定你的向下转换操作会成功的时候，你才可以使用强制类型转换操作符（forced type cast operator）－－as!。当你尝试转换了一个错误的类型时，这种形式的操作会触发一个运行时错误。  </p>
<p>下面的例子向你展示了可选类型转换操作（as?）的使用：这个例子检查了在shapes数组中的某一项shape是否是一个正方形（square）或者三角形（triangle）。每一次找出Shape时，会对相对应的变量squares和triangles加一，最后输出结果值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Triangle: NamedShape &#123;</div><div class="line">    init(sideLength: Double, name: String) &#123;</div><div class="line">        super.init(name: name)</div><div class="line">        numberOfSides = 3</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">let shapesArray = [Triangle(sideLength: 1.5, name: &quot;triangle1&quot;), Triangle(sideLength: 4.2, name: &quot;triangle2&quot;), Square(sideLength: 3.2, name: &quot;square1&quot;), Square(sideLength: 2.7, name: &quot;square2&quot;)]</div><div class="line">var squares = 0</div><div class="line">var triangles = 0</div><div class="line">for shape in shapesArray &#123;</div><div class="line">    if let square = shape as? Square &#123;</div><div class="line">        squares++</div><div class="line">    &#125; else if let triangle = shape as? Triangle &#123;</div><div class="line">        triangles++</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">print(&quot;\(squares) squares and \(triangles) triangles.&quot;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>动手操作</strong><br>尝试将 as?替换成as!。这时候你会捕获到什么错误？  </p>
</blockquote>
<h3 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h3><p>在Swift中，类不是定义数据类型的唯一的方式。枚举（enumerations）和结构体(structures)和类有相似的功能，但是它们在不同的上下文中却大有用处。 </p>
<p>枚举可以为一组相关的值定义一个公共的类型，它能让你在你的代码中使用一种类型安全的方式去处理这些值。枚举可以拥有与它们相关的方法。  </p>
<p>使用enum创建一个枚举。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">enum Rank: Int &#123;</div><div class="line">    case Ace = 1</div><div class="line">    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten</div><div class="line">    case Jack, Queen, King</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .Ace:</div><div class="line">            return &quot;ace&quot;</div><div class="line">        case .Jack:</div><div class="line">            return &quot;jack&quot;</div><div class="line">        case .Queen:</div><div class="line">            return &quot;queen&quot;</div><div class="line">        case .King:</div><div class="line">            return &quot;king&quot;</div><div class="line">        default:</div><div class="line">            return String(self.rawValue)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let ace = Rank.Ace</div><div class="line">let aceRawValue = ace.rawValue</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，枚举的原始值的类型是整型（Int），所以你只需要指定第一个原始值。剩余的原始值按照顺序赋值。你同样可以使用字符串或者浮点数作为枚举的原始值。使用rawValue属性可以访问到枚举成员的原始值。  </p>
<p>使用init?(rawValue:)构造函数创建一个从原始值开始的枚举的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if let convertedRank = Rank(rawValue: 3) &#123;</div><div class="line">    let threeDescription = convertedRank.simpleDescription()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>枚举的成员值是实际值，而不是通过另外一种方式写的原始值。事实上，在原始值没有实际意义的情况下，你不必提供原始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">enum Suit &#123;</div><div class="line">    case Spades, Hearts, Diamonds, Clubs</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .Spades:</div><div class="line">            return &quot;spades&quot;</div><div class="line">        case .Hearts:</div><div class="line">            return &quot;hearts&quot;</div><div class="line">        case .Diamonds:</div><div class="line">            return &quot;diamonds&quot;</div><div class="line">        case .Clubs:</div><div class="line">            return &quot;clubs&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let hearts = Suit.Hearts</div><div class="line">let heartsDescription = hearts.simpleDescription()</div></pre></td></tr></table></figure></p>
<p>注意上面的例子中，枚举中的成员Hearts中两种不同的表示方式：当hearts常量被赋值时，枚举成员Suit.Hearts是它的完整写法，因为常量没有隐式的类型指定。在switch中，枚举成员.Hearts是其简写的形式，因为self的值已经明确地确定为suit。任何时候，在你知道值的类型之后，你可以使用简写的形式。  </p>
<p>结构体和类一样支持很多相同的行为，包括方法和构造器。类和结构体之间最重要的一个区别是：结构体在代码中被传递时总是以复制的形式传递的，但是类是以引用传递的。结构体在定义轻量级的数据类型上是很完美的，它不需要有很多类似于继承和类型转换的功能。   </p>
<p>使用struct来创建一个结构体。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Card &#123;</div><div class="line">    var rank: Rank</div><div class="line">    var suit: Suit</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        return &quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let threeOfSpades = Card(rank: .Three, suit: .Spades)</div><div class="line">let threeOfSpadesDescription = threeOfSpades.simpleDescription()</div></pre></td></tr></table></figure>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议是定义了一系列方法、属性和其它特定任务或功能的蓝图。协议事实上不提供任何这些需求的实现，它只是描述了实现的轮廓。协议定义之后可以被一个类、结构体或枚举采用以提供那些需求的具体实现。任何满足了协议的需求的行为，我们称之为遵循（conform）了那个协议。   </p>
<p>使用protocol定义一个协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol ExampleProtocol &#123;</div><div class="line">    var simpleDescription: String &#123; get &#125;</div><div class="line">    func adjust()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意<br>在simpleDescription属性之后的{ get }表示这是一个只读的属性，意味着这个属性的值只能获取，不能改变。</p>
</blockquote>
<p>协议可以要求遵循它的类型持有指定的实例属性，实例方法，操作符和下标脚本。协议要求遵循它的类型必须实现其中的实例方法和类型方法。这些方法和普通的实例和类型方法一样，定义在协议中，但是没有圆括号或方法体。  </p>
<p>类、结构体和枚举通过在其名字后面写上一个冒号，冒号后列出协议的名字的写法来实现遵循协议。一个类型可以遵循任何数量的协议，协议中间通过逗号分隔。如果类有父类，那么父类必须出现在列表的最前面，后面才跟着协议。你需要通过实现所有的协议的需求来实现协议的遵循。  </p>
<p>下面的例子中，SimpleClass采用了ExampleProtocol协议，通过实现simpleDescription属性和adjust()方法以实现遵循该协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class SimpleClass: ExampleProtocol &#123;</div><div class="line">    var simpleDescription: String = &quot;A very simple class.&quot;</div><div class="line">    var anotherProperty: Int = 69105</div><div class="line">    func adjust() &#123;</div><div class="line">        simpleDescription += &quot;  Now 100% adjusted.&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var a = SimpleClass()</div><div class="line">a.adjust()</div><div class="line">let aDescription = a.simpleDescription</div></pre></td></tr></table></figure></p>
<p>协议是高级类型，这意味着它们可以当做其它命名过的类型使用。比如，你可以创建一个ExampleProtocol数组，然后在数组的每一个实例中调用adjust()方法（因为在数组中的任何实例会保证实现了adjust()方法－－这是协议的要求）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class SimpleClass2: ExampleProtocol &#123;</div><div class="line">    var simpleDescription: String = &quot;Another very simple class.&quot;</div><div class="line">    func adjust() &#123;</div><div class="line">        simpleDescription += &quot;  Adjusted.&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">var protocolArray: [ExampleProtocol] = [SimpleClass(), SimpleClass(), SimpleClass2()]</div><div class="line">for instance in protocolArray &#123;</div><div class="line">    instance.adjust()</div><div class="line">&#125;</div><div class="line">protocolArray</div></pre></td></tr></table></figure></p>
<h3 id="Swift和Cocoa-Touch框架"><a href="#Swift和Cocoa-Touch框架" class="headerlink" title="Swift和Cocoa Touch框架"></a>Swift和Cocoa Touch框架</h3><p>Cocoa Touch是用来开发苹果iOS应用的一个框架的集合，Swift是按照与Cocoa Touch框架无缝衔接来设计的。在你往后的课程的学习中，你会对Swift如何与Cocoa Touch框架进行交互有一个基本的理解。  </p>
<p>至此，你已经学习了Swift标准库中所有的数据类型。Swift标准库(Swift standard library)是为Swift设计的一个数据类型和功能的集合，并将这些融合成为一门语言。在标准库中，像String和Array这样的类型就是数据类型的一些例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let sampleString: String = &quot;hello&quot;</div><div class="line">let sampleArray: Array = [1, 2, 3.1415, 23, 42]</div></pre></td></tr></table></figure></p>
<blockquote>
<p>动手操作<br>通过Option-click在Xcode中的数据类型，查阅Swift标准库中的类型的具体实现。在上面的playground代码中，在String和Array上面Option-click，查看相应的结果。  </p>
</blockquote>
<p>当你在开发iOS应用的时候，你不会仅仅使用到Swift标准库。在iOS应用开发中，另一个你会频繁用到的框架是UIKit。UIKit包含了针对应用的UI层级（用户界面，usere interface）设计的有用的类。  </p>
<p>要使用UIKit，只需要在Swift文件或playground文件中简单地把它当做模块导入即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import UIKit</div></pre></td></tr></table></figure></p>
<p>导入了UIKit之后，你可以使用Swift语法来使用UIKit中的类型以及它们相关的方法、属性等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let redSquare = UIView(frame: CGRect(x: 0, y: 0, width: 44, height: 44))</div><div class="line">redSquare.backgroundColor = UIColor.redColor()</div></pre></td></tr></table></figure></p>
<p>在教程中很多介绍到的类都是来自于UIKit中的，所以你会经常看到这个导入UIKit的语句。  </p>
<p>在经过大量的Swift知识的介绍之后，相信你已经准备好在下一门课程中创建一个功能完整的应用了。虽然这一章节结束之后，你将不会再需要使用到playground了，但是请记住在应用开发中playground是一个很强大的工具，它能帮助你调试，查看上下文代码，提高原型设计效率。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.ruanjiawei.com/2016/08/08/Start-Developing-iOS-Apps-Swift-2/" data-id="cirkubl6j0005iv7gelfpwzht" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Swift/">Swift</a></div><div class="post-nav"><a href="/2016/08/08/Start-Developing-iOS-Apps-Swift-1/" class="next">苹果官方iOS入门教程译版之第一章：Jump Right In</a></div><div data-thread-key="2016/08/08/Start-Developing-iOS-Apps-Swift-2/" data-title="苹果官方iOS入门教程译版之第二章：Learn the Essentials of Swift" data-url="http://www.ruanjiawei.com/2016/08/08/Start-Developing-iOS-Apps-Swift-2/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/08/08/Start-Developing-iOS-Apps-Swift-2/" data-title="苹果官方iOS入门教程译版之第二章：Learn the Essentials of Swift" data-url="http://www.ruanjiawei.com/2016/08/08/Start-Developing-iOS-Apps-Swift-2/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.ruanjiawei.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/躁动的心/">躁动的心</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/死宅/" style="font-size: 15px;">死宅</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/08/08/Start-Developing-iOS-Apps-Swift-2/">苹果官方iOS入门教程译版之第二章：Learn the Essentials of Swift</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/08/Start-Developing-iOS-Apps-Swift-1/">苹果官方iOS入门教程译版之第一章：Jump Right In</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/07/my-first-blog/">迷糊的周末</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="http://www.75team.com/" title="奇舞团博客" target="_blank">奇舞团博客</a><ul></ul><a href="http://www.zhangxinxu.com/wordpress/" title="张鑫旭" target="_blank">张鑫旭</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2016 <a href="/." rel="nofollow">开车上纽北 </a>| 桂ICP备14003578号 | Powered by Hexo</div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'ruanjiawei'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>